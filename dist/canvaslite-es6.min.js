(function(window, document, undefined) {
"use strict";

/**
* Storing all defaults value
* that is used in Library
*/
let libDefaults = {
    canvasHeight: 300,
    canvasWidth: 500,
    fill: '#fff',
    stroke: '#000',
    strokeWidth: 4
  },
  userDefaults = {
  };
/**
* Constructor function to initialize CanvasLite
*/
class CanvasLite {
  constructor (id, height, width) {
    this.rootGroup = new Group(this, null, true);
    this.brush = new Painter(id, height, width, this.rootGroup);
  }

  /**
  * Create a new rect with configurations
  * Config Ex: {
  *   x : 0,
  *   y : 0,
  *   height: 100,
  *   width : 100,
  *   fill : '#345',
  *   stroke : '#987'
  * }
  */
  rect (config, group) {
    let _config = {};
    if (typeof config !== 'object') {
      _config.x = arguments[0];
      _config.y = arguments[1];
      _config.width = arguments[2];
      _config.height = arguments[3];
      if (arguments[4] instanceof Group || !arguments[4]) {
        return new Rect(this, _config, arguments[4]);
      }
      _config.fill = arguments[4];
      if (arguments[5] instanceof Group || !arguments[5]) {
        return new Rect(this, _config, arguments[5]);
      }
      _config.stroke = arguments[5];
      return new Rect(this, _config, arguments[6]);
    }
    return new Rect(this, config, group);
  }
  /**
  * Create a new element
  */
  element () {
    return new BasicElement(this);
  }
  /**
  * Create a new group
  */
  group () {
    return new Group(this);
  }
  /**
  * clearing canvas
  */
  clear () {
    this.brush.clearCanvas();
  }
}
// Exposing CanvasLite to global space
window.CanvasLite = CanvasLite;

// Getting accurate requestAnimationFrame
(function getAccurateRequestAnimationFrame () {
  var lastTime = 0,
    vendors = ['ms', 'moz', 'webkit', 'o'],
    x = 0,
    xx = vendors.length,
    currTime = 0,
    timeToCall = 0,
    id = 0;
  for (; x < xx && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
    window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
      currTime = new Date().getTime();
      timeToCall = Math.max(0, 16 - (currTime - lastTime));
      id = window.setTimeout(function () { callback(currTime + timeToCall); },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }
}());

/**
* Basic Element class
* Groups and other Elements inherits this
* contains basic methods and properties required by all groups or elements.
*/
class BasicElement {
  /**
  * BasiElement constructor
  * assign the group, store canvas
  * set type initially to 'basicEl'
  */
  constructor (canvas, group) {
    if (!canvas) {
      throw Error('canvas not provided');
    }
    // Element specific configuration object
    this.elConfig = {};
    this.canvas = canvas;
    this.config = {
      type: 'basicEl',
      visible: true
    };
    // Initially assign root group if
    // group not provided
    if (group) {
      if (!(group instanceof Group)) {
        throw Error('Not a proper Group');
      }
      group.add(this);
    } else {
      if (canvas.rootGroup) {
        canvas.rootGroup.add(this);
      } else {
        this.isRoot = true;
      }
    }
  }
  is (type) {
    type += '';
    return this.config.type.toLowerCase() === type.toLowerCase();
  }
  /**
  * Assign new group or
  * get the current assigned group
  */
  group (group) {
    // If group is provided assign, otherwise
    // return current group
    var res;
    if (group) {
      this.group().remove(this);
      group.add(this);
      // Notify group changed
      this.__notifyChange__();
      return res;
    } else {
      return this.__group__;
    }
  }
  /**
  * Erase current element
  */
  erase () {
    var key;
    this.group.remove(this);
    // delete every property of element
    for (key in this) {
      if (this.hasOwnProperty(key)) {
        delete this[key];
      }
    }
    // Notify element erased
    this.__notifyChange__();
  }
  /**
  * Hide current element
  */
  hide () {
    if (this.config.visible) {
      this.config.visible = false;
      this.__notifyChange__(true);
    }
    return this;
  }
  /**
  * Show current element
  */
  show () {
    if (!this.config.visible) {
      this.config.visible = true;
      this.__notifyChange__();
    }
    return this;
  }
  /**
  * Toggle current element's visibility
  */
  toggle () {
    this.config.visible = !this.config.visible;
    this.__notifyChange__();
    return this;
  }
  /**
  * Behave when property of element is changed
  */
  __notifyChange__ (forceNotify) {
    if (this.config && this.config.visible || forceNotify) {
      // Notify change only if visible
      // and if element exists
      if (!this.isRoot) {
        this.group().__notifyChange__();
      } else if (this.canvas.brush) {
        this.canvas.brush.paintAll();
      }
    }
  }
  /**
  * change attributes of element,
  * takes key, value pair or
  * config object
  */
  attr (key, value) {
    var config = {},
      change = false,
      k = '',
      v = '';
    // If no arguments return current
    if (!key && !value) {
      return this.elConfig;
    }
    // No configurations in group
    if (!(this instanceof BasicElement) || this instanceof Group) {
      return this;
    } else if (typeof key === 'string' && (typeof value === 'string' || typeof value === 'number')) {
      config[key] = value;
    } else if (typeof key === 'object') {
      config = key;
    } else if (key && !value) {
      return this.elConfig[key];
    } else {
      return this;
    }
    for (k in config) {
      if (this.elConfig[k] !== config[k]) {
        this.elConfig[k] = config[k];
        change = true;
      }
    }
    if (change) {
      this.__notifyChange__();
    }
    return this;
  }
  /**
  * Base draw method; If validations passed element
  * will be actually drawn
  */
  draw (context) {
    // check if context is proper
    if (!context && !(context instanceof window.CanvasRenderingContext2D)) {
      throw Error('Incorrect context');
    }
    // do not draw if invisible
    if (!this.config.visible) {
      return;
    } else {
      this.__draw__(context);
    }
  }
  /**
  * @private
  * Abstract draw method
  */
  __draw__ (context) {
    // Draw method to be overridden by every element
  }
  /**
  * Push element to last in the group
  */
  sendBack () {
    this.group().__sendToBack__(this);
  }
  /**
  * Push element to first in the group
  */
  bringFront () {
    this.group().__sendToFront__(this);
  }
}

/**
* Manage groups that elements belong to
* extends BasicElement
*/
class Group extends BasicElement {
  constructor (canvas, group, isRoot) {
    super(canvas, group, isRoot);
    // Set type to group
    this.config.type = 'group';
    this.__members__ = [];
    // Notify element added
    this.__notifyChange__();
  }
  /**
  * Check if is proper element or group
  */
  __checkIfEl__ (element) {
    if (!(element instanceof BasicElement)) {
      throw Error('Only elements or groups can be added');
    }
  }
  /**
  * Check if is proper group
  */
  __checkGroup__ (element) {
    if (!(element instanceof Group)) {
      throw Error('Group expected');
    }
  }
  /**
  * Add new elements or groups
  * to current group
  */
  add (element) {
    let i = 0;
    // If Array add all elements
    if (!isNaN(element.length)) {
      for (i = element.length; i--;) {
        this.add(element[i]);
      }
      return this;
    }
    this.__checkIfEl__(element);
    // Remove previous group;
    if (element.group()) {
      element.group().remove(element);
    }
    // asssign new group
    element.__group__ = this;
    this.__members__.push(element);
    return this;
  }
  /**
  * Add new elements or groups
  * to current group from different group
  */
  addAllFrom (group) {
    let arr,
      i = 0;
    this.__checkGroup__(group);
    arr = group.__members__;
    for (i = arr.length; i--;) {

    }
  }
  /**
  * Remove element is member of current group
  */
  remove (element) {
    let members = this.__members__,
      i = 0,
      ii = members.length,
      j = 0;
    this.__checkIfEl__(element);
    for (; i < ii; ++i) {
      if (members[i] === element) {
        break;
      }
    }
    if (i === ii) { // Element not found
      throw Error('Element not in current group');
    } else { // Remove the element
      for (j = i + 1; j < ii; ++j) {
        members[j - 1] = members[j];
      }
      members.pop();
      delete element.group;
    }
    return this;
  }
  /**
  * Remove all elements
  */
  removeAll () {
    let members = this.__members__,
      i = members.length;
    for (; i--;) {
      delete members[i].group;
    }
    // Remove references of all elements
    this.__members__ = [];
    return this;
  }
  /**
  * Overriding method
  * Erase current group and all its children
  */
  erase () {
    let members = this.__members__,
      i = members.length;
    // remove all children
    for (; i--;) {
      members[i].erase();
    }
    // Remove self
    super.erase();
  }
  /**
  * Function to command all group element to draw itself;
  */
  __draw__ (context) {
    let members = this.__members__,
      i = 0,
      ii = members.length;
    // Iterating over each member;
    // commanding to draw
    for (; i < ii; ++i) {
      members[i].draw(context);
    }
  }
  /**
  * Push element to last in the group
  */
  __sendToBack__ (el) {
    let members = this.__members__,
      i = 0,
      pos = -1;
    this.__checkIfEl__(el);
    pos = members.indexOf(el);
    if (pos !== -1) {
      for (i = pos - 1; i >= 0; --i) {
        members[i + 1] = members[i];
      }
      members[0] = el;
    }
  }
  /**
  * Push element to last in the group
  */
  __sendToFront__ (el) {
    let members = this.__members__,
      i = 0,
      ii = members.length,
      pos = -1;
    this.__checkIfEl__(el);
    pos = members.indexOf(el);
    if (pos !== -1) {
      for (i = pos + 1; i < ii; ++i) {
        members[i - 1] = members[i];
      }
      members[ii - 1] = el;
    }
  }
}

/**
* Line element
*/
class Rect extends BasicElement {
  constructor (canvas, elConfig, group) {
    super(canvas, group);
    this.config.type = 'rect';
    this.elConfig = elConfig;
    // Notify element added
    this.__notifyChange__();
  }
  /**
  * Function to describe how element will be drawn
  */
  __attr__ (config) {

  }
  /**
  * Function to describe how element will be drawn
  */
  __draw__ (context) {
    let i,
      rect = this,
      config = rect.elConfig;
    context.beginPath();
    context.rect(config.x, config.y, config.width, config.height);
    context.fillStyle = config.fill || libDefaults.fill;
    context.strokeStyle = config.stroke || libDefaults.stroke;
    context.lineWidth = config.strokeWidth || libDefaults.strokeWidth;
    context.stroke();
    context.fill();
  }
} // end Line

// Class to manage rendering of elements
class Painter {
  constructor (id, height, width, rootGroup) {
    let painter = this,
      canvas;
    painter.canvas = {
      rootEl: document.getElementById(id),
      canvasEl: document.createElement('canvas'),
      height: height || libDefaults.canvasHeight,
      width: width || libDefaults.canvasWidth
    };
    canvas = painter.canvas;
    canvas.rootEl.appendChild(canvas.canvasEl);
    // Setting height and width of canvas
    canvas.canvasEl.setAttribute('width', canvas.width);
    canvas.canvasEl.setAttribute('height', canvas.height);
    // Setting fallback
    canvas.canvasEl.innerHTML = 'Your browser doesn\'t support canvas!';
    // Getting context and root group
    canvas.context = canvas.canvasEl.getContext('2d');
    canvas.rootGroup = rootGroup;
    this.clearCanvas();
  }
  /**
  * Clearing canvas with state saved
  */
  clearCanvas (saveState) {
    let painter = this,
      canvas = painter.canvas,
      context = canvas.context;
    // Store the current transformation matrix
    if (saveState) {
      context.save();
    }
    context.beginPath();
    context.fillStyle = 'white';
    context.strokeStyle = 'white';
    context.rect(0, 0, canvas.width, canvas.height);
    context.stroke();
    context.fill();
    // Restore the transform
    if (saveState) {
      context.restore();
    }
  }
  // Paint all visible items;
  paintAll () {
    this.clearCanvas();
    this.canvas.rootGroup.draw(this.canvas.context);
  }
}
}(window, document));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJjYW52YXNsaXRlLWVzNi5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuKiBTdG9yaW5nIGFsbCBkZWZhdWx0cyB2YWx1ZVxuKiB0aGF0IGlzIHVzZWQgaW4gTGlicmFyeVxuKi9cbmxldCBsaWJEZWZhdWx0cyA9IHtcbiAgICBjYW52YXNIZWlnaHQ6IDMwMCxcbiAgICBjYW52YXNXaWR0aDogNTAwLFxuICAgIGZpbGw6ICcjZmZmJyxcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBzdHJva2VXaWR0aDogNFxuICB9LFxuICB1c2VyRGVmYXVsdHMgPSB7XG4gIH07XG4vKipcbiogQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBDYW52YXNMaXRlXG4qL1xuY2xhc3MgQ2FudmFzTGl0ZSB7XG4gIGNvbnN0cnVjdG9yIChpZCwgaGVpZ2h0LCB3aWR0aCkge1xuICAgIHRoaXMucm9vdEdyb3VwID0gbmV3IEdyb3VwKHRoaXMsIG51bGwsIHRydWUpO1xuICAgIHRoaXMuYnJ1c2ggPSBuZXcgUGFpbnRlcihpZCwgaGVpZ2h0LCB3aWR0aCwgdGhpcy5yb290R3JvdXApO1xuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlIGEgbmV3IHJlY3Qgd2l0aCBjb25maWd1cmF0aW9uc1xuICAqIENvbmZpZyBFeDoge1xuICAqICAgeCA6IDAsXG4gICogICB5IDogMCxcbiAgKiAgIGhlaWdodDogMTAwLFxuICAqICAgd2lkdGggOiAxMDAsXG4gICogICBmaWxsIDogJyMzNDUnLFxuICAqICAgc3Ryb2tlIDogJyM5ODcnXG4gICogfVxuICAqL1xuICByZWN0IChjb25maWcsIGdyb3VwKSB7XG4gICAgbGV0IF9jb25maWcgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIF9jb25maWcueCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIF9jb25maWcueSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIF9jb25maWcud2lkdGggPSBhcmd1bWVudHNbMl07XG4gICAgICBfY29uZmlnLmhlaWdodCA9IGFyZ3VtZW50c1szXTtcbiAgICAgIGlmIChhcmd1bWVudHNbNF0gaW5zdGFuY2VvZiBHcm91cCB8fCAhYXJndW1lbnRzWzRdKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLCBfY29uZmlnLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgX2NvbmZpZy5maWxsID0gYXJndW1lbnRzWzRdO1xuICAgICAgaWYgKGFyZ3VtZW50c1s1XSBpbnN0YW5jZW9mIEdyb3VwIHx8ICFhcmd1bWVudHNbNV0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMsIF9jb25maWcsIGFyZ3VtZW50c1s1XSk7XG4gICAgICB9XG4gICAgICBfY29uZmlnLnN0cm9rZSA9IGFyZ3VtZW50c1s1XTtcbiAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLCBfY29uZmlnLCBhcmd1bWVudHNbNl0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcywgY29uZmlnLCBncm91cCk7XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgKi9cbiAgZWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIG5ldyBCYXNpY0VsZW1lbnQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlIGEgbmV3IGdyb3VwXG4gICovXG4gIGdyb3VwICgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIGNsZWFyaW5nIGNhbnZhc1xuICAqL1xuICBjbGVhciAoKSB7XG4gICAgdGhpcy5icnVzaC5jbGVhckNhbnZhcygpO1xuICB9XG59XG4vLyBFeHBvc2luZyBDYW52YXNMaXRlIHRvIGdsb2JhbCBzcGFjZVxud2luZG93LkNhbnZhc0xpdGUgPSBDYW52YXNMaXRlO1xuXG4vLyBHZXR0aW5nIGFjY3VyYXRlIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuKGZ1bmN0aW9uIGdldEFjY3VyYXRlUmVxdWVzdEFuaW1hdGlvbkZyYW1lICgpIHtcbiAgdmFyIGxhc3RUaW1lID0gMCxcbiAgICB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXSxcbiAgICB4ID0gMCxcbiAgICB4eCA9IHZlbmRvcnMubGVuZ3RoLFxuICAgIGN1cnJUaW1lID0gMCxcbiAgICB0aW1lVG9DYWxsID0gMCxcbiAgICBpZCA9IDA7XG4gIGZvciAoOyB4IDwgeHggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XG4gICAgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gIH1cblxuICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LFxuICAgICAgICB0aW1lVG9DYWxsKTtcbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG4gIH1cbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcbiAgfVxufSgpKTtcblxuLyoqXG4qIEJhc2ljIEVsZW1lbnQgY2xhc3NcbiogR3JvdXBzIGFuZCBvdGhlciBFbGVtZW50cyBpbmhlcml0cyB0aGlzXG4qIGNvbnRhaW5zIGJhc2ljIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgcmVxdWlyZWQgYnkgYWxsIGdyb3VwcyBvciBlbGVtZW50cy5cbiovXG5jbGFzcyBCYXNpY0VsZW1lbnQge1xuICAvKipcbiAgKiBCYXNpRWxlbWVudCBjb25zdHJ1Y3RvclxuICAqIGFzc2lnbiB0aGUgZ3JvdXAsIHN0b3JlIGNhbnZhc1xuICAqIHNldCB0eXBlIGluaXRpYWxseSB0byAnYmFzaWNFbCdcbiAgKi9cbiAgY29uc3RydWN0b3IgKGNhbnZhcywgZ3JvdXApIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NhbnZhcyBub3QgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgLy8gRWxlbWVudCBzcGVjaWZpYyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgIHRoaXMuZWxDb25maWcgPSB7fTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIHR5cGU6ICdiYXNpY0VsJyxcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9O1xuICAgIC8vIEluaXRpYWxseSBhc3NpZ24gcm9vdCBncm91cCBpZlxuICAgIC8vIGdyb3VwIG5vdCBwcm92aWRlZFxuICAgIGlmIChncm91cCkge1xuICAgICAgaWYgKCEoZ3JvdXAgaW5zdGFuY2VvZiBHcm91cCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vdCBhIHByb3BlciBHcm91cCcpO1xuICAgICAgfVxuICAgICAgZ3JvdXAuYWRkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FudmFzLnJvb3RHcm91cCkge1xuICAgICAgICBjYW52YXMucm9vdEdyb3VwLmFkZCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaXNSb290ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXMgKHR5cGUpIHtcbiAgICB0eXBlICs9ICcnO1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy50eXBlLnRvTG93ZXJDYXNlKCkgPT09IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvKipcbiAgKiBBc3NpZ24gbmV3IGdyb3VwIG9yXG4gICogZ2V0IHRoZSBjdXJyZW50IGFzc2lnbmVkIGdyb3VwXG4gICovXG4gIGdyb3VwIChncm91cCkge1xuICAgIC8vIElmIGdyb3VwIGlzIHByb3ZpZGVkIGFzc2lnbiwgb3RoZXJ3aXNlXG4gICAgLy8gcmV0dXJuIGN1cnJlbnQgZ3JvdXBcbiAgICB2YXIgcmVzO1xuICAgIGlmIChncm91cCkge1xuICAgICAgdGhpcy5ncm91cCgpLnJlbW92ZSh0aGlzKTtcbiAgICAgIGdyb3VwLmFkZCh0aGlzKTtcbiAgICAgIC8vIE5vdGlmeSBncm91cCBjaGFuZ2VkXG4gICAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZ3JvdXBfXztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRXJhc2UgY3VycmVudCBlbGVtZW50XG4gICovXG4gIGVyYXNlICgpIHtcbiAgICB2YXIga2V5O1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgIC8vIGRlbGV0ZSBldmVyeSBwcm9wZXJ0eSBvZiBlbGVtZW50XG4gICAgZm9yIChrZXkgaW4gdGhpcykge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3RpZnkgZWxlbWVudCBlcmFzZWRcbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgfVxuICAvKipcbiAgKiBIaWRlIGN1cnJlbnQgZWxlbWVudFxuICAqL1xuICBoaWRlICgpIHtcbiAgICBpZiAodGhpcy5jb25maWcudmlzaWJsZSkge1xuICAgICAgdGhpcy5jb25maWcudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgKiBTaG93IGN1cnJlbnQgZWxlbWVudFxuICAqL1xuICBzaG93ICgpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLnZpc2libGUpIHtcbiAgICAgIHRoaXMuY29uZmlnLnZpc2libGUgPSB0cnVlO1xuICAgICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAqIFRvZ2dsZSBjdXJyZW50IGVsZW1lbnQncyB2aXNpYmlsaXR5XG4gICovXG4gIHRvZ2dsZSAoKSB7XG4gICAgdGhpcy5jb25maWcudmlzaWJsZSA9ICF0aGlzLmNvbmZpZy52aXNpYmxlO1xuICAgIHRoaXMuX19ub3RpZnlDaGFuZ2VfXygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAqIEJlaGF2ZSB3aGVuIHByb3BlcnR5IG9mIGVsZW1lbnQgaXMgY2hhbmdlZFxuICAqL1xuICBfX25vdGlmeUNoYW5nZV9fIChmb3JjZU5vdGlmeSkge1xuICAgIGlmICh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy52aXNpYmxlIHx8IGZvcmNlTm90aWZ5KSB7XG4gICAgICAvLyBOb3RpZnkgY2hhbmdlIG9ubHkgaWYgdmlzaWJsZVxuICAgICAgLy8gYW5kIGlmIGVsZW1lbnQgZXhpc3RzXG4gICAgICBpZiAoIXRoaXMuaXNSb290KSB7XG4gICAgICAgIHRoaXMuZ3JvdXAoKS5fX25vdGlmeUNoYW5nZV9fKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2FudmFzLmJydXNoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmJydXNoLnBhaW50QWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIGNoYW5nZSBhdHRyaWJ1dGVzIG9mIGVsZW1lbnQsXG4gICogdGFrZXMga2V5LCB2YWx1ZSBwYWlyIG9yXG4gICogY29uZmlnIG9iamVjdFxuICAqL1xuICBhdHRyIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNvbmZpZyA9IHt9LFxuICAgICAgY2hhbmdlID0gZmFsc2UsXG4gICAgICBrID0gJycsXG4gICAgICB2ID0gJyc7XG4gICAgLy8gSWYgbm8gYXJndW1lbnRzIHJldHVybiBjdXJyZW50XG4gICAgaWYgKCFrZXkgJiYgIXZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbENvbmZpZztcbiAgICB9XG4gICAgLy8gTm8gY29uZmlndXJhdGlvbnMgaW4gZ3JvdXBcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQmFzaWNFbGVtZW50KSB8fCB0aGlzIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uZmlnID0ga2V5O1xuICAgIH0gZWxzZSBpZiAoa2V5ICYmICF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxDb25maWdba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvciAoayBpbiBjb25maWcpIHtcbiAgICAgIGlmICh0aGlzLmVsQ29uZmlnW2tdICE9PSBjb25maWdba10pIHtcbiAgICAgICAgdGhpcy5lbENvbmZpZ1trXSA9IGNvbmZpZ1trXTtcbiAgICAgICAgY2hhbmdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAqIEJhc2UgZHJhdyBtZXRob2Q7IElmIHZhbGlkYXRpb25zIHBhc3NlZCBlbGVtZW50XG4gICogd2lsbCBiZSBhY3R1YWxseSBkcmF3blxuICAqL1xuICBkcmF3IChjb250ZXh0KSB7XG4gICAgLy8gY2hlY2sgaWYgY29udGV4dCBpcyBwcm9wZXJcbiAgICBpZiAoIWNvbnRleHQgJiYgIShjb250ZXh0IGluc3RhbmNlb2Ygd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdJbmNvcnJlY3QgY29udGV4dCcpO1xuICAgIH1cbiAgICAvLyBkbyBub3QgZHJhdyBpZiBpbnZpc2libGVcbiAgICBpZiAoIXRoaXMuY29uZmlnLnZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fX2RyYXdfXyhjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogQHByaXZhdGVcbiAgKiBBYnN0cmFjdCBkcmF3IG1ldGhvZFxuICAqL1xuICBfX2RyYXdfXyAoY29udGV4dCkge1xuICAgIC8vIERyYXcgbWV0aG9kIHRvIGJlIG92ZXJyaWRkZW4gYnkgZXZlcnkgZWxlbWVudFxuICB9XG4gIC8qKlxuICAqIFB1c2ggZWxlbWVudCB0byBsYXN0IGluIHRoZSBncm91cFxuICAqL1xuICBzZW5kQmFjayAoKSB7XG4gICAgdGhpcy5ncm91cCgpLl9fc2VuZFRvQmFja19fKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIFB1c2ggZWxlbWVudCB0byBmaXJzdCBpbiB0aGUgZ3JvdXBcbiAgKi9cbiAgYnJpbmdGcm9udCAoKSB7XG4gICAgdGhpcy5ncm91cCgpLl9fc2VuZFRvRnJvbnRfXyh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiogTWFuYWdlIGdyb3VwcyB0aGF0IGVsZW1lbnRzIGJlbG9uZyB0b1xuKiBleHRlbmRzIEJhc2ljRWxlbWVudFxuKi9cbmNsYXNzIEdyb3VwIGV4dGVuZHMgQmFzaWNFbGVtZW50IHtcbiAgY29uc3RydWN0b3IgKGNhbnZhcywgZ3JvdXAsIGlzUm9vdCkge1xuICAgIHN1cGVyKGNhbnZhcywgZ3JvdXAsIGlzUm9vdCk7XG4gICAgLy8gU2V0IHR5cGUgdG8gZ3JvdXBcbiAgICB0aGlzLmNvbmZpZy50eXBlID0gJ2dyb3VwJztcbiAgICB0aGlzLl9fbWVtYmVyc19fID0gW107XG4gICAgLy8gTm90aWZ5IGVsZW1lbnQgYWRkZWRcbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgfVxuICAvKipcbiAgKiBDaGVjayBpZiBpcyBwcm9wZXIgZWxlbWVudCBvciBncm91cFxuICAqL1xuICBfX2NoZWNrSWZFbF9fIChlbGVtZW50KSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEJhc2ljRWxlbWVudCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdPbmx5IGVsZW1lbnRzIG9yIGdyb3VwcyBjYW4gYmUgYWRkZWQnKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogQ2hlY2sgaWYgaXMgcHJvcGVyIGdyb3VwXG4gICovXG4gIF9fY2hlY2tHcm91cF9fIChlbGVtZW50KSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEdyb3VwKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0dyb3VwIGV4cGVjdGVkJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIEFkZCBuZXcgZWxlbWVudHMgb3IgZ3JvdXBzXG4gICogdG8gY3VycmVudCBncm91cFxuICAqL1xuICBhZGQgKGVsZW1lbnQpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSWYgQXJyYXkgYWRkIGFsbCBlbGVtZW50c1xuICAgIGlmICghaXNOYU4oZWxlbWVudC5sZW5ndGgpKSB7XG4gICAgICBmb3IgKGkgPSBlbGVtZW50Lmxlbmd0aDsgaS0tOykge1xuICAgICAgICB0aGlzLmFkZChlbGVtZW50W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9fY2hlY2tJZkVsX18oZWxlbWVudCk7XG4gICAgLy8gUmVtb3ZlIHByZXZpb3VzIGdyb3VwO1xuICAgIGlmIChlbGVtZW50Lmdyb3VwKCkpIHtcbiAgICAgIGVsZW1lbnQuZ3JvdXAoKS5yZW1vdmUoZWxlbWVudCk7XG4gICAgfVxuICAgIC8vIGFzc3NpZ24gbmV3IGdyb3VwXG4gICAgZWxlbWVudC5fX2dyb3VwX18gPSB0aGlzO1xuICAgIHRoaXMuX19tZW1iZXJzX18ucHVzaChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgKiBBZGQgbmV3IGVsZW1lbnRzIG9yIGdyb3Vwc1xuICAqIHRvIGN1cnJlbnQgZ3JvdXAgZnJvbSBkaWZmZXJlbnQgZ3JvdXBcbiAgKi9cbiAgYWRkQWxsRnJvbSAoZ3JvdXApIHtcbiAgICBsZXQgYXJyLFxuICAgICAgaSA9IDA7XG4gICAgdGhpcy5fX2NoZWNrR3JvdXBfXyhncm91cCk7XG4gICAgYXJyID0gZ3JvdXAuX19tZW1iZXJzX187XG4gICAgZm9yIChpID0gYXJyLmxlbmd0aDsgaS0tOykge1xuXG4gICAgfVxuICB9XG4gIC8qKlxuICAqIFJlbW92ZSBlbGVtZW50IGlzIG1lbWJlciBvZiBjdXJyZW50IGdyb3VwXG4gICovXG4gIHJlbW92ZSAoZWxlbWVudCkge1xuICAgIGxldCBtZW1iZXJzID0gdGhpcy5fX21lbWJlcnNfXyxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSBtZW1iZXJzLmxlbmd0aCxcbiAgICAgIGogPSAwO1xuICAgIHRoaXMuX19jaGVja0lmRWxfXyhlbGVtZW50KTtcbiAgICBmb3IgKDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmIChtZW1iZXJzW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gaWkpIHsgLy8gRWxlbWVudCBub3QgZm91bmRcbiAgICAgIHRocm93IEVycm9yKCdFbGVtZW50IG5vdCBpbiBjdXJyZW50IGdyb3VwJyk7XG4gICAgfSBlbHNlIHsgLy8gUmVtb3ZlIHRoZSBlbGVtZW50XG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGlpOyArK2opIHtcbiAgICAgICAgbWVtYmVyc1tqIC0gMV0gPSBtZW1iZXJzW2pdO1xuICAgICAgfVxuICAgICAgbWVtYmVycy5wb3AoKTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50Lmdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgKiBSZW1vdmUgYWxsIGVsZW1lbnRzXG4gICovXG4gIHJlbW92ZUFsbCAoKSB7XG4gICAgbGV0IG1lbWJlcnMgPSB0aGlzLl9fbWVtYmVyc19fLFxuICAgICAgaSA9IG1lbWJlcnMubGVuZ3RoO1xuICAgIGZvciAoOyBpLS07KSB7XG4gICAgICBkZWxldGUgbWVtYmVyc1tpXS5ncm91cDtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXMgb2YgYWxsIGVsZW1lbnRzXG4gICAgdGhpcy5fX21lbWJlcnNfXyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAqIE92ZXJyaWRpbmcgbWV0aG9kXG4gICogRXJhc2UgY3VycmVudCBncm91cCBhbmQgYWxsIGl0cyBjaGlsZHJlblxuICAqL1xuICBlcmFzZSAoKSB7XG4gICAgbGV0IG1lbWJlcnMgPSB0aGlzLl9fbWVtYmVyc19fLFxuICAgICAgaSA9IG1lbWJlcnMubGVuZ3RoO1xuICAgIC8vIHJlbW92ZSBhbGwgY2hpbGRyZW5cbiAgICBmb3IgKDsgaS0tOykge1xuICAgICAgbWVtYmVyc1tpXS5lcmFzZSgpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VsZlxuICAgIHN1cGVyLmVyYXNlKCk7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gdG8gY29tbWFuZCBhbGwgZ3JvdXAgZWxlbWVudCB0byBkcmF3IGl0c2VsZjtcbiAgKi9cbiAgX19kcmF3X18gKGNvbnRleHQpIHtcbiAgICBsZXQgbWVtYmVycyA9IHRoaXMuX19tZW1iZXJzX18sXG4gICAgICBpID0gMCxcbiAgICAgIGlpID0gbWVtYmVycy5sZW5ndGg7XG4gICAgLy8gSXRlcmF0aW5nIG92ZXIgZWFjaCBtZW1iZXI7XG4gICAgLy8gY29tbWFuZGluZyB0byBkcmF3XG4gICAgZm9yICg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBtZW1iZXJzW2ldLmRyYXcoY29udGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIFB1c2ggZWxlbWVudCB0byBsYXN0IGluIHRoZSBncm91cFxuICAqL1xuICBfX3NlbmRUb0JhY2tfXyAoZWwpIHtcbiAgICBsZXQgbWVtYmVycyA9IHRoaXMuX19tZW1iZXJzX18sXG4gICAgICBpID0gMCxcbiAgICAgIHBvcyA9IC0xO1xuICAgIHRoaXMuX19jaGVja0lmRWxfXyhlbCk7XG4gICAgcG9zID0gbWVtYmVycy5pbmRleE9mKGVsKTtcbiAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgZm9yIChpID0gcG9zIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWVtYmVyc1tpICsgMV0gPSBtZW1iZXJzW2ldO1xuICAgICAgfVxuICAgICAgbWVtYmVyc1swXSA9IGVsO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBQdXNoIGVsZW1lbnQgdG8gbGFzdCBpbiB0aGUgZ3JvdXBcbiAgKi9cbiAgX19zZW5kVG9Gcm9udF9fIChlbCkge1xuICAgIGxldCBtZW1iZXJzID0gdGhpcy5fX21lbWJlcnNfXyxcbiAgICAgIGkgPSAwLFxuICAgICAgaWkgPSBtZW1iZXJzLmxlbmd0aCxcbiAgICAgIHBvcyA9IC0xO1xuICAgIHRoaXMuX19jaGVja0lmRWxfXyhlbCk7XG4gICAgcG9zID0gbWVtYmVycy5pbmRleE9mKGVsKTtcbiAgICBpZiAocG9zICE9PSAtMSkge1xuICAgICAgZm9yIChpID0gcG9zICsgMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbWVtYmVyc1tpIC0gMV0gPSBtZW1iZXJzW2ldO1xuICAgICAgfVxuICAgICAgbWVtYmVyc1tpaSAtIDFdID0gZWw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuKiBMaW5lIGVsZW1lbnRcbiovXG5jbGFzcyBSZWN0IGV4dGVuZHMgQmFzaWNFbGVtZW50IHtcbiAgY29uc3RydWN0b3IgKGNhbnZhcywgZWxDb25maWcsIGdyb3VwKSB7XG4gICAgc3VwZXIoY2FudmFzLCBncm91cCk7XG4gICAgdGhpcy5jb25maWcudHlwZSA9ICdyZWN0JztcbiAgICB0aGlzLmVsQ29uZmlnID0gZWxDb25maWc7XG4gICAgLy8gTm90aWZ5IGVsZW1lbnQgYWRkZWRcbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgfVxuICAvKipcbiAgKiBGdW5jdGlvbiB0byBkZXNjcmliZSBob3cgZWxlbWVudCB3aWxsIGJlIGRyYXduXG4gICovXG4gIF9fYXR0cl9fIChjb25maWcpIHtcblxuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIGRlc2NyaWJlIGhvdyBlbGVtZW50IHdpbGwgYmUgZHJhd25cbiAgKi9cbiAgX19kcmF3X18gKGNvbnRleHQpIHtcbiAgICBsZXQgaSxcbiAgICAgIHJlY3QgPSB0aGlzLFxuICAgICAgY29uZmlnID0gcmVjdC5lbENvbmZpZztcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQucmVjdChjb25maWcueCwgY29uZmlnLnksIGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb25maWcuZmlsbCB8fCBsaWJEZWZhdWx0cy5maWxsO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb25maWcuc3Ryb2tlIHx8IGxpYkRlZmF1bHRzLnN0cm9rZTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGNvbmZpZy5zdHJva2VXaWR0aCB8fCBsaWJEZWZhdWx0cy5zdHJva2VXaWR0aDtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG59IC8vIGVuZCBMaW5lXG5cbi8vIENsYXNzIHRvIG1hbmFnZSByZW5kZXJpbmcgb2YgZWxlbWVudHNcbmNsYXNzIFBhaW50ZXIge1xuICBjb25zdHJ1Y3RvciAoaWQsIGhlaWdodCwgd2lkdGgsIHJvb3RHcm91cCkge1xuICAgIGxldCBwYWludGVyID0gdGhpcyxcbiAgICAgIGNhbnZhcztcbiAgICBwYWludGVyLmNhbnZhcyA9IHtcbiAgICAgIHJvb3RFbDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgICAgY2FudmFzRWw6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgfHwgbGliRGVmYXVsdHMuY2FudmFzSGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpZHRoIHx8IGxpYkRlZmF1bHRzLmNhbnZhc1dpZHRoXG4gICAgfTtcbiAgICBjYW52YXMgPSBwYWludGVyLmNhbnZhcztcbiAgICBjYW52YXMucm9vdEVsLmFwcGVuZENoaWxkKGNhbnZhcy5jYW52YXNFbCk7XG4gICAgLy8gU2V0dGluZyBoZWlnaHQgYW5kIHdpZHRoIG9mIGNhbnZhc1xuICAgIGNhbnZhcy5jYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgY2FudmFzLndpZHRoKTtcbiAgICBjYW52YXMuY2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAvLyBTZXR0aW5nIGZhbGxiYWNrXG4gICAgY2FudmFzLmNhbnZhc0VsLmlubmVySFRNTCA9ICdZb3VyIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgY2FudmFzISc7XG4gICAgLy8gR2V0dGluZyBjb250ZXh0IGFuZCByb290IGdyb3VwXG4gICAgY2FudmFzLmNvbnRleHQgPSBjYW52YXMuY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMucm9vdEdyb3VwID0gcm9vdEdyb3VwO1xuICAgIHRoaXMuY2xlYXJDYW52YXMoKTtcbiAgfVxuICAvKipcbiAgKiBDbGVhcmluZyBjYW52YXMgd2l0aCBzdGF0ZSBzYXZlZFxuICAqL1xuICBjbGVhckNhbnZhcyAoc2F2ZVN0YXRlKSB7XG4gICAgbGV0IHBhaW50ZXIgPSB0aGlzLFxuICAgICAgY2FudmFzID0gcGFpbnRlci5jYW52YXMsXG4gICAgICBjb250ZXh0ID0gY2FudmFzLmNvbnRleHQ7XG4gICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgaWYgKHNhdmVTdGF0ZSkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgfVxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuICAgIGNvbnRleHQucmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgLy8gUmVzdG9yZSB0aGUgdHJhbnNmb3JtXG4gICAgaWYgKHNhdmVTdGF0ZSkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIC8vIFBhaW50IGFsbCB2aXNpYmxlIGl0ZW1zO1xuICBwYWludEFsbCAoKSB7XG4gICAgdGhpcy5jbGVhckNhbnZhcygpO1xuICAgIHRoaXMuY2FudmFzLnJvb3RHcm91cC5kcmF3KHRoaXMuY2FudmFzLmNvbnRleHQpO1xuICB9XG59XG59KHdpbmRvdywgZG9jdW1lbnQpKTtcbiJdLCJmaWxlIjoiY2FudmFzbGl0ZS1lczYubWluLmpzIn0=
