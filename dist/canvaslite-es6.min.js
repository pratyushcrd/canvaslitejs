(function(window, document, undefined) {
"use strict";

/**
* Storing all defaults value
* that is used in Library
*/
let libDefaults = {
    canvasHeight: 300,
    canvasWidth: 500,
    fill: '#fff',
    stroke: '#000',
    strokeWidth: 4
  },
  userDefaults = {
  };
/**
* Constructor function to initialize CanvasLite
*/
class CanvasLite {
  constructor (id, height, width) {
    this.rootGroup = new Group(this, null, true);
    this.brush = new Painter(id, height, width, this.rootGroup);
  }

  /**
  * Create a new rect with configurations
  * Config Ex: {
  *   x : 0,
  *   y : 0,
  *   height: 100,
  *   width : 100,
  *   fill : '#345',
  *   stroke : '#987'
  * }
  */
  rect (config, group) {
    let _config = {};
    if (typeof config !== 'object') {
      _config.x = arguments[0];
      _config.y = arguments[1];
      _config.width = arguments[2];
      _config.height = arguments[3];
      if (arguments[4] instanceof Group || !arguments[4]) {
        return new Rect(this, _config, arguments[4]);
      }
      _config.fill = arguments[4];
      if (arguments[5] instanceof Group || !arguments[5]) {
        return new Rect(this, _config, arguments[5]);
      }
      _config.stroke = arguments[5];
      return new Rect(this, _config, arguments[6]);
    }
    return new Rect(this, config, group);
  }
  /**
  * Create a new element
  */
  element () {
    return new BasicElement(this);
  }
  /**
  * Create a new group
  */
  group () {
    return new Group(this);
  }
  /**
  * clearing canvas
  */
  clear () {
    this.brush.clearCanvas();
  }
}
// Exposing CanvasLite to global space
window.CanvasLite = CanvasLite;

// Getting accurate requestAnimationFrame
var lastTime = 0,
  vendors = ['ms', 'moz', 'webkit', 'o'],
  x = 0,
  xx = vendors.length,
  currTime = 0,
  timeToCall = 0,
  id = 0;
for (; x < xx && !window.requestAnimationFrame; ++x) {
  window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
  window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
  window[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = function (callback, element) {
    currTime = new Date().getTime();
    timeToCall = Math.max(0, 16 - (currTime - lastTime));
    id = window.setTimeout(function () { callback(currTime + timeToCall); },
      timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
}

/**
* Basic Element class
* Groups and other Elements inherits this
* contains basic methods and properties required by all groups or elements.
*/
class BasicElement {
  /**
  * BasiElement constructor
  * assign the group, store canvas
  * set type initially to 'basicEl'
  */
  constructor (canvas, group) {
    if (!canvas) {
      throw Error('canvas not provided');
    }
    // Element specific configuration object
    this.elConfig = {};
    this.canvas = canvas;
    this.config = {
      type: 'basicEl',
      visible: true
    };
    // Initially assign root group if
    // group not provided
    if (group) {
      if (!(group instanceof Group)) {
        throw Error('Not a proper Group');
      }
      group.add(this);
    } else {
      if (canvas.rootGroup) {
        canvas.rootGroup.add(this);
      } else {
        this.isRoot = true;
      }
    }
  }
  is (type) {
    type += '';
    return this.config.type.toLowerCase() === type.toLowerCase();
  }
  /**
  * Assign new group or
  * get the current assigned group
  */
  group (group) {
    // If group is provided assign, otherwise
    // return current group
    var res;
    if (group) {
      this.group().remove(this);
      group.add(this);
      // Notify group changed
      this.__notifyChange__();
      return res;
    } else {
      return this.__group__;
    }
  }
  /**
  * Erase current element
  */
  erase (dontNotify) {
    var key;
    this.group().remove(this);
    // Notify element erased unless group is erasing it
    if (!dontNotify) {
      this.__notifyChange__();
    }
    // delete every property of element
    for (key in this) {
      if (this.hasOwnProperty(key)) {
        delete this[key];
      }
    }
    // removing proto
    this.__proto__ = null;
    return this;
  }
  /**
  * Hide current element
  */
  hide () {
    if (this.config.visible) {
      this.config.visible = false;
      this.__notifyChange__(true);
    }
    return this;
  }
  /**
  * Show current element
  */
  show () {
    if (!this.config.visible) {
      this.config.visible = true;
      this.__notifyChange__();
    }
    return this;
  }
  /**
  * Toggle current element's visibility
  */
  toggle () {
    this.config.visible = !this.config.visible;
    this.__notifyChange__();
    return this;
  }
  /**
  * Behave when property of element is changed
  */
  __notifyChange__ (forceNotify) {
    if (forceNotify || this.config && this.config.visible) {
      // Notify change only if visible
      // and if element exists
      if (!this.isRoot) {
        this.group().__notifyChange__();
      } else if (this.canvas.brush) {
        this.canvas.brush.paintAll();
      }
    }
  }
  /**
  * change attributes of element,
  * takes key, value pair or
  * config object
  */
  attr (key, value) {
    var config = {},
      change = false,
      k = '',
      v = '';
    // If no arguments return current
    if (!key && !value) {
      return this.elConfig;
    }
    // No configurations in group
    if (!(this instanceof BasicElement) || this instanceof Group) {
      return this;
    } else if (typeof key === 'string' && (typeof value === 'string' || typeof value === 'number')) {
      config[key] = value;
    } else if (typeof key === 'object') {
      config = key;
    } else if (key && !value) {
      return this.elConfig[key];
    } else {
      return this;
    }
    for (k in config) {
      if (this.elConfig[k] !== config[k]) {
        this.elConfig[k] = config[k];
        change = true;
      }
    }
    if (change) {
      this.__notifyChange__();
    }
    return this;
  }
  /**
  * Base draw method; If validations passed element
  * will be actually drawn
  */
  draw (context) {
    // check if context is proper
    if (!context && !(context instanceof window.CanvasRenderingContext2D)) {
      throw Error('Incorrect context');
    }
    // do not draw if invisible
    if (!this.config.visible) {
      return;
    } else {
      this.__draw__(context);
    }
  }
  /**
  * @private
  * Abstract draw method
  */
  __draw__ (context) {
    // Draw method to be overridden by every element
  }
  /**
  * Push element to last in the group
  */
  sendBack () {
    this.group().__sendToBack__(this);
    this.__notifyChange__();
  }
  /**
  * Push element to first in the group
  */
  bringFront () {
    this.group().__sendToFront__(this);
    this.__notifyChange__();
  }
}

/**
* Manage groups that elements belong to
* extends BasicElement
*/
class Group extends BasicElement {
  constructor (canvas, group, isRoot) {
    super(canvas, group, isRoot);
    // Set type to group
    this.config.type = 'group';
    this.__members__ = [];
    // Notify element added
    this.__notifyChange__();
  }
  /**
  * Check if is proper element or group
  */
  __checkIfEl__ (element) {
    if (!(element instanceof BasicElement)) {
      throw Error('Only elements or groups can be added');
    }
  }
  /**
  * Check if is proper group
  */
  __checkGroup__ (element) {
    if (!(element instanceof Group)) {
      throw Error('Group expected');
    }
  }
  /**
  * Add new elements or groups
  * to current group
  */
  add (element) {
    let i = 0;
    // If Array add all elements
    if (!isNaN(element.length)) {
      for (i = element.length; i--;) {
        this.add(element[i]);
      }
      return this;
    }
    this.__checkIfEl__(element);
    // Remove previous group;
    if (element.group()) {
      element.group().remove(element);
    }
    // asssign new group
    element.__group__ = this;
    this.__members__.push(element);
    this.__notifyChange__();
    return this;
  }
  /**
  * Add new elements or groups
  * to current group from different group
  */
  addAllFrom (group) {
    let arr,
      i = 0;
    this.__checkGroup__(group);
    arr = group.__members__;
    for (i = arr.length; i--;) {

    }
  }
  /**
  * Remove element is member of current group
  */
  remove (element) {
    let members = this.__members__,
      i = 0,
      ii = members.length,
      j = 0;
    this.__checkIfEl__(element);
    i = members.indexOf(element);
    if (!~i) { // Element not found
      throw Error('Element not in current group');
    } else { // Remove the element
      members.splice(i, 1);
      delete element.group;
    }
    return this;
  }
  /**
  * Remove all elements
  */
  removeAll () {
    let members = this.__members__,
      i = members.length;
    for (; i--;) {
      members[i].pop();
    }
    // Remove references of all elements
    this.__members__ = [];
    return this;
  }
  /**
  * Overriding method
  * Erase current group and all its children
  */
  erase () {
    let members = this.__members__,
      i = members.length;
    // remove all children
    for (; i--;) {
      members[i].erase();
    }
    this.__notifyChange__();
    // Remove self
    super.erase();
  }
  /**
  * Function to command all group element to draw itself;
  */
  __draw__ (context) {
    let members = this.__members__,
      i = 0,
      // If group is not drawn completely; members check
      // If not case ; when group is initialized its BasicEl
      // constructor is called which adds it toroot group and calls
      // for __notify__ which then commands all group to draw
      // but then this group would not have its member as its initialization
      // is not complete thus will cause error
      ii = members && members.length || 0;
    // Iterating over each member;
    // commanding to draw
    for (; i < ii; ++i) {
      members[i].__draw__(context);
    }
  }
  /**
  * Push element to last in the group
  */
  __sendToBack__ (el) {
    let members = this.__members__,
      i = 0,
      pos = -1;
    this.__checkIfEl__(el);
    pos = members.indexOf(el);
    if (pos !== -1) {
      for (i = pos - 1; i >= 0; --i) {
        members[i + 1] = members[i];
      }
      members[0] = el;
    }
  }
  /**
  * Push element to last in the group
  */
  __sendToFront__ (el) {
    let members = this.__members__,
      i = 0,
      ii = members.length,
      pos = -1;
    this.__checkIfEl__(el);
    pos = members.indexOf(el);
    if (pos !== -1) {
      for (i = pos + 1; i < ii; ++i) {
        members[i - 1] = members[i];
      }
      members[ii - 1] = el;
    }
  }
}

/**
* Line element
*/
class Rect extends BasicElement {
  constructor (canvas, elConfig, group) {
    super(canvas, group);
    this.config.type = 'rect';
    this.elConfig = elConfig;
    // Notify element added
    this.__notifyChange__();
  }
  /**
  * Function to describe how element will be drawn
  */
  __attr__ (config) {

  }
  /**
  * Function to describe how element will be drawn
  */
  __draw__ (context) {
    let i,
      rect = this,
      config = rect.elConfig;
    context.beginPath();
    context.rect(config.x, config.y, config.width, config.height);
    context.fillStyle = config.fill || libDefaults.fill;
    context.strokeStyle = config.stroke || libDefaults.stroke;
    context.lineWidth = config.strokeWidth || libDefaults.strokeWidth;
    context.stroke();
    context.fill();
  }
} // end Line

// Class to manage rendering of elements
class Painter {
  constructor (id, height, width, rootGroup) {
    let painter = this,
      canvas;
    painter.canvas = {
      rootEl: document.getElementById(id),
      canvasEl: document.createElement('canvas'),
      height: height || libDefaults.canvasHeight,
      width: width || libDefaults.canvasWidth
    };
    canvas = painter.canvas;
    canvas.rootEl.appendChild(canvas.canvasEl);
    // Setting height and width of canvas
    canvas.canvasEl.setAttribute('width', canvas.width);
    canvas.canvasEl.setAttribute('height', canvas.height);
    // Setting fallback
    canvas.canvasEl.innerHTML = 'Your browser doesn\'t support canvas!';
    // Getting context and root group
    canvas.context = canvas.canvasEl.getContext('2d');
    canvas.rootGroup = rootGroup;
    this.clearCanvas();
  }
  /**
  * Clearing canvas with state saved
  */
  clearCanvas (saveState) {
    let painter = this,
      canvas = painter.canvas,
      context = canvas.context;
    // Store the current transformation matrix
    if (saveState) {
      context.save();
    }
    context.beginPath();
    context.fillStyle = 'white';
    context.strokeStyle = 'white';
    context.rect(0, 0, canvas.width, canvas.height);
    context.stroke();
    context.fill();
    // Restore the transform
    if (saveState) {
      context.restore();
    }
  }
  // Paint all visible items;
  paintAll () {
    this.clearCanvas();
    this.canvas.rootGroup.draw(this.canvas.context);
  }
}

'use strict';
var paper = new CanvasLite('canvas', 900, 900),
  rootGroup = paper.rootGroup,
  r0 = paper.rect(0, 0, 100, 100, '#E97592', '#FFAC8B'),
  r1 = paper.rect(66, 55, 100, 100, '#B7AC54', '#95B830'),
  r2 = paper.rect(114, 126, 100, 100, '#BEC4A1', '#0ADAA5'),
  r3 = paper.rect(194, 148, 100, 100, '#035C69', '#8A8BF3'),
  r4 = paper.rect(255, 182, 100, 100, '#4F1168', '#A87E21'),
  r5 = paper.rect(275, 259, 100, 100, '#91E400', '#3AB78E'),
  r6 = paper.rect(350, 310, 100, 100, '#73F1E6', '#CAAC6C'),
  r7 = paper.rect(351, 375, 100, 100, '#D3009C', '#FF4494'),
  r8 = paper.rect(395, 376, 100, 100, '#97BD77', '#9ECD89'),
  r9 = paper.rect(488, 462, 100, 100, '#2D1385', '#DBB16A'),
  r10 = paper.rect(497, 523, 100, 100, '#888447', '#0716CB'),
  r11 = paper.rect(561, 600, 100, 100, '#E2B1FA', '#CD4031'),
  r12 = paper.rect(593, 648, 100, 100, '#712C35', '#C097EB'),
  r13 = paper.rect(612, 695, 100, 100, '#8D5D7E', '#3B250F'),
  r14 = paper.rect(689, 696, 100, 100, '#2A8C5A', '#DCADBB'),
  g = paper.group(),
  error = console.error.bind(console),
  x = 0,
  y = 0,
  h = 0,
  w = 0,
  t = 0;

if (rootGroup.__members__.length !== 16) {
  error('Members length not correct');
}

g.add([r1, r3, r5]);
g.hide();

if (rootGroup.__members__.length !== 13) {
  error('Members length not correct after appending items in group');
}

if (g.config.visible) {
  error('Element not hidden');
}

g.show();

if (!g.config.visible) {
  error('Element not shown');
}

g.erase();

if (g.__proto__) {
  error('Group not erased');
}
if (r1.__proto__) {
  error('Group member not erased');
}
if (r3.__proto__) {
  error('Group member not erased');
}
if (r5.__proto__) {
  error('Group member not erased');
}

r1 = paper.rect(66, 55, 100, 100, '#B7AC54', '#95B830');
r3 = paper.rect(194, 148, 100, 100, '#035C69', '#8A8BF3');
r5 = paper.rect(275, 259, 100, 100, '#91E400', '#3AB78E');
g = paper.group();
g.add([r1, r3, r5]);

if (rootGroup.__members__.length !== 13) {
  error('Members length not correct');
}

if (g.__members__.length !== 3) {
  error('Members length not correct');
}
}(window, document));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJjYW52YXNsaXRlLWVzNi5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuKiBTdG9yaW5nIGFsbCBkZWZhdWx0cyB2YWx1ZVxuKiB0aGF0IGlzIHVzZWQgaW4gTGlicmFyeVxuKi9cbmxldCBsaWJEZWZhdWx0cyA9IHtcbiAgICBjYW52YXNIZWlnaHQ6IDMwMCxcbiAgICBjYW52YXNXaWR0aDogNTAwLFxuICAgIGZpbGw6ICcjZmZmJyxcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBzdHJva2VXaWR0aDogNFxuICB9LFxuICB1c2VyRGVmYXVsdHMgPSB7XG4gIH07XG4vKipcbiogQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBDYW52YXNMaXRlXG4qL1xuY2xhc3MgQ2FudmFzTGl0ZSB7XG4gIGNvbnN0cnVjdG9yIChpZCwgaGVpZ2h0LCB3aWR0aCkge1xuICAgIHRoaXMucm9vdEdyb3VwID0gbmV3IEdyb3VwKHRoaXMsIG51bGwsIHRydWUpO1xuICAgIHRoaXMuYnJ1c2ggPSBuZXcgUGFpbnRlcihpZCwgaGVpZ2h0LCB3aWR0aCwgdGhpcy5yb290R3JvdXApO1xuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlIGEgbmV3IHJlY3Qgd2l0aCBjb25maWd1cmF0aW9uc1xuICAqIENvbmZpZyBFeDoge1xuICAqICAgeCA6IDAsXG4gICogICB5IDogMCxcbiAgKiAgIGhlaWdodDogMTAwLFxuICAqICAgd2lkdGggOiAxMDAsXG4gICogICBmaWxsIDogJyMzNDUnLFxuICAqICAgc3Ryb2tlIDogJyM5ODcnXG4gICogfVxuICAqL1xuICByZWN0IChjb25maWcsIGdyb3VwKSB7XG4gICAgbGV0IF9jb25maWcgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIF9jb25maWcueCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIF9jb25maWcueSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIF9jb25maWcud2lkdGggPSBhcmd1bWVudHNbMl07XG4gICAgICBfY29uZmlnLmhlaWdodCA9IGFyZ3VtZW50c1szXTtcbiAgICAgIGlmIChhcmd1bWVudHNbNF0gaW5zdGFuY2VvZiBHcm91cCB8fCAhYXJndW1lbnRzWzRdKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLCBfY29uZmlnLCBhcmd1bWVudHNbNF0pO1xuICAgICAgfVxuICAgICAgX2NvbmZpZy5maWxsID0gYXJndW1lbnRzWzRdO1xuICAgICAgaWYgKGFyZ3VtZW50c1s1XSBpbnN0YW5jZW9mIEdyb3VwIHx8ICFhcmd1bWVudHNbNV0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMsIF9jb25maWcsIGFyZ3VtZW50c1s1XSk7XG4gICAgICB9XG4gICAgICBfY29uZmlnLnN0cm9rZSA9IGFyZ3VtZW50c1s1XTtcbiAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLCBfY29uZmlnLCBhcmd1bWVudHNbNl0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlY3QodGhpcywgY29uZmlnLCBncm91cCk7XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgKi9cbiAgZWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIG5ldyBCYXNpY0VsZW1lbnQodGhpcyk7XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlIGEgbmV3IGdyb3VwXG4gICovXG4gIGdyb3VwICgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKHRoaXMpO1xuICB9XG4gIC8qKlxuICAqIGNsZWFyaW5nIGNhbnZhc1xuICAqL1xuICBjbGVhciAoKSB7XG4gICAgdGhpcy5icnVzaC5jbGVhckNhbnZhcygpO1xuICB9XG59XG4vLyBFeHBvc2luZyBDYW52YXNMaXRlIHRvIGdsb2JhbCBzcGFjZVxud2luZG93LkNhbnZhc0xpdGUgPSBDYW52YXNMaXRlO1xuXG4vLyBHZXR0aW5nIGFjY3VyYXRlIHJlcXVlc3RBbmltYXRpb25GcmFtZVxudmFyIGxhc3RUaW1lID0gMCxcbiAgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ10sXG4gIHggPSAwLFxuICB4eCA9IHZlbmRvcnMubGVuZ3RoLFxuICBjdXJyVGltZSA9IDAsXG4gIHRpbWVUb0NhbGwgPSAwLFxuICBpZCA9IDA7XG5mb3IgKDsgeCA8IHh4ICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8XG4gIHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xufVxuXG5pZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xuICAgIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTsgfSxcbiAgICAgIHRpbWVUb0NhbGwpO1xuICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgIHJldHVybiBpZDtcbiAgfTtcbn1cbmlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH07XG59XG5cbi8qKlxuKiBCYXNpYyBFbGVtZW50IGNsYXNzXG4qIEdyb3VwcyBhbmQgb3RoZXIgRWxlbWVudHMgaW5oZXJpdHMgdGhpc1xuKiBjb250YWlucyBiYXNpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHJlcXVpcmVkIGJ5IGFsbCBncm91cHMgb3IgZWxlbWVudHMuXG4qL1xuY2xhc3MgQmFzaWNFbGVtZW50IHtcbiAgLyoqXG4gICogQmFzaUVsZW1lbnQgY29uc3RydWN0b3JcbiAgKiBhc3NpZ24gdGhlIGdyb3VwLCBzdG9yZSBjYW52YXNcbiAgKiBzZXQgdHlwZSBpbml0aWFsbHkgdG8gJ2Jhc2ljRWwnXG4gICovXG4gIGNvbnN0cnVjdG9yIChjYW52YXMsIGdyb3VwKSB7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIHRocm93IEVycm9yKCdjYW52YXMgbm90IHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIC8vIEVsZW1lbnQgc3BlY2lmaWMgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICB0aGlzLmVsQ29uZmlnID0ge307XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICB0eXBlOiAnYmFzaWNFbCcsXG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfTtcbiAgICAvLyBJbml0aWFsbHkgYXNzaWduIHJvb3QgZ3JvdXAgaWZcbiAgICAvLyBncm91cCBub3QgcHJvdmlkZWRcbiAgICBpZiAoZ3JvdXApIHtcbiAgICAgIGlmICghKGdyb3VwIGluc3RhbmNlb2YgR3JvdXApKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgYSBwcm9wZXIgR3JvdXAnKTtcbiAgICAgIH1cbiAgICAgIGdyb3VwLmFkZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNhbnZhcy5yb290R3JvdXApIHtcbiAgICAgICAgY2FudmFzLnJvb3RHcm91cC5hZGQodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzUm9vdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzICh0eXBlKSB7XG4gICAgdHlwZSArPSAnJztcbiAgICByZXR1cm4gdGhpcy5jb25maWcudHlwZS50b0xvd2VyQ2FzZSgpID09PSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLyoqXG4gICogQXNzaWduIG5ldyBncm91cCBvclxuICAqIGdldCB0aGUgY3VycmVudCBhc3NpZ25lZCBncm91cFxuICAqL1xuICBncm91cCAoZ3JvdXApIHtcbiAgICAvLyBJZiBncm91cCBpcyBwcm92aWRlZCBhc3NpZ24sIG90aGVyd2lzZVxuICAgIC8vIHJldHVybiBjdXJyZW50IGdyb3VwXG4gICAgdmFyIHJlcztcbiAgICBpZiAoZ3JvdXApIHtcbiAgICAgIHRoaXMuZ3JvdXAoKS5yZW1vdmUodGhpcyk7XG4gICAgICBncm91cC5hZGQodGhpcyk7XG4gICAgICAvLyBOb3RpZnkgZ3JvdXAgY2hhbmdlZFxuICAgICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dyb3VwX187XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIEVyYXNlIGN1cnJlbnQgZWxlbWVudFxuICAqL1xuICBlcmFzZSAoZG9udE5vdGlmeSkge1xuICAgIHZhciBrZXk7XG4gICAgdGhpcy5ncm91cCgpLnJlbW92ZSh0aGlzKTtcbiAgICAvLyBOb3RpZnkgZWxlbWVudCBlcmFzZWQgdW5sZXNzIGdyb3VwIGlzIGVyYXNpbmcgaXRcbiAgICBpZiAoIWRvbnROb3RpZnkpIHtcbiAgICAgIHRoaXMuX19ub3RpZnlDaGFuZ2VfXygpO1xuICAgIH1cbiAgICAvLyBkZWxldGUgZXZlcnkgcHJvcGVydHkgb2YgZWxlbWVudFxuICAgIGZvciAoa2V5IGluIHRoaXMpIHtcbiAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVtb3ZpbmcgcHJvdG9cbiAgICB0aGlzLl9fcHJvdG9fXyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogSGlkZSBjdXJyZW50IGVsZW1lbnRcbiAgKi9cbiAgaGlkZSAoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnZpc2libGUpIHtcbiAgICAgIHRoaXMuY29uZmlnLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19ub3RpZnlDaGFuZ2VfXyh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogU2hvdyBjdXJyZW50IGVsZW1lbnRcbiAgKi9cbiAgc2hvdyAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy52aXNpYmxlKSB7XG4gICAgICB0aGlzLmNvbmZpZy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19ub3RpZnlDaGFuZ2VfXygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgKiBUb2dnbGUgY3VycmVudCBlbGVtZW50J3MgdmlzaWJpbGl0eVxuICAqL1xuICB0b2dnbGUgKCkge1xuICAgIHRoaXMuY29uZmlnLnZpc2libGUgPSAhdGhpcy5jb25maWcudmlzaWJsZTtcbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgKiBCZWhhdmUgd2hlbiBwcm9wZXJ0eSBvZiBlbGVtZW50IGlzIGNoYW5nZWRcbiAgKi9cbiAgX19ub3RpZnlDaGFuZ2VfXyAoZm9yY2VOb3RpZnkpIHtcbiAgICBpZiAoZm9yY2VOb3RpZnkgfHwgdGhpcy5jb25maWcgJiYgdGhpcy5jb25maWcudmlzaWJsZSkge1xuICAgICAgLy8gTm90aWZ5IGNoYW5nZSBvbmx5IGlmIHZpc2libGVcbiAgICAgIC8vIGFuZCBpZiBlbGVtZW50IGV4aXN0c1xuICAgICAgaWYgKCF0aGlzLmlzUm9vdCkge1xuICAgICAgICB0aGlzLmdyb3VwKCkuX19ub3RpZnlDaGFuZ2VfXygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbnZhcy5icnVzaCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5icnVzaC5wYWludEFsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgKiBjaGFuZ2UgYXR0cmlidXRlcyBvZiBlbGVtZW50LFxuICAqIHRha2VzIGtleSwgdmFsdWUgcGFpciBvclxuICAqIGNvbmZpZyBvYmplY3RcbiAgKi9cbiAgYXR0ciAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjb25maWcgPSB7fSxcbiAgICAgIGNoYW5nZSA9IGZhbHNlLFxuICAgICAgayA9ICcnLFxuICAgICAgdiA9ICcnO1xuICAgIC8vIElmIG5vIGFyZ3VtZW50cyByZXR1cm4gY3VycmVudFxuICAgIGlmICgha2V5ICYmICF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxDb25maWc7XG4gICAgfVxuICAgIC8vIE5vIGNvbmZpZ3VyYXRpb25zIGluIGdyb3VwXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJhc2ljRWxlbWVudCkgfHwgdGhpcyBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICBjb25maWdba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbmZpZyA9IGtleTtcbiAgICB9IGVsc2UgaWYgKGtleSAmJiAhdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsQ29uZmlnW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3IgKGsgaW4gY29uZmlnKSB7XG4gICAgICBpZiAodGhpcy5lbENvbmZpZ1trXSAhPT0gY29uZmlnW2tdKSB7XG4gICAgICAgIHRoaXMuZWxDb25maWdba10gPSBjb25maWdba107XG4gICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgIHRoaXMuX19ub3RpZnlDaGFuZ2VfXygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgKiBCYXNlIGRyYXcgbWV0aG9kOyBJZiB2YWxpZGF0aW9ucyBwYXNzZWQgZWxlbWVudFxuICAqIHdpbGwgYmUgYWN0dWFsbHkgZHJhd25cbiAgKi9cbiAgZHJhdyAoY29udGV4dCkge1xuICAgIC8vIGNoZWNrIGlmIGNvbnRleHQgaXMgcHJvcGVyXG4gICAgaWYgKCFjb250ZXh0ICYmICEoY29udGV4dCBpbnN0YW5jZW9mIHdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpKSB7XG4gICAgICB0aHJvdyBFcnJvcignSW5jb3JyZWN0IGNvbnRleHQnKTtcbiAgICB9XG4gICAgLy8gZG8gbm90IGRyYXcgaWYgaW52aXNpYmxlXG4gICAgaWYgKCF0aGlzLmNvbmZpZy52aXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX19kcmF3X18oY29udGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIEBwcml2YXRlXG4gICogQWJzdHJhY3QgZHJhdyBtZXRob2RcbiAgKi9cbiAgX19kcmF3X18gKGNvbnRleHQpIHtcbiAgICAvLyBEcmF3IG1ldGhvZCB0byBiZSBvdmVycmlkZGVuIGJ5IGV2ZXJ5IGVsZW1lbnRcbiAgfVxuICAvKipcbiAgKiBQdXNoIGVsZW1lbnQgdG8gbGFzdCBpbiB0aGUgZ3JvdXBcbiAgKi9cbiAgc2VuZEJhY2sgKCkge1xuICAgIHRoaXMuZ3JvdXAoKS5fX3NlbmRUb0JhY2tfXyh0aGlzKTtcbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgfVxuICAvKipcbiAgKiBQdXNoIGVsZW1lbnQgdG8gZmlyc3QgaW4gdGhlIGdyb3VwXG4gICovXG4gIGJyaW5nRnJvbnQgKCkge1xuICAgIHRoaXMuZ3JvdXAoKS5fX3NlbmRUb0Zyb250X18odGhpcyk7XG4gICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gIH1cbn1cblxuLyoqXG4qIE1hbmFnZSBncm91cHMgdGhhdCBlbGVtZW50cyBiZWxvbmcgdG9cbiogZXh0ZW5kcyBCYXNpY0VsZW1lbnRcbiovXG5jbGFzcyBHcm91cCBleHRlbmRzIEJhc2ljRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yIChjYW52YXMsIGdyb3VwLCBpc1Jvb3QpIHtcbiAgICBzdXBlcihjYW52YXMsIGdyb3VwLCBpc1Jvb3QpO1xuICAgIC8vIFNldCB0eXBlIHRvIGdyb3VwXG4gICAgdGhpcy5jb25maWcudHlwZSA9ICdncm91cCc7XG4gICAgdGhpcy5fX21lbWJlcnNfXyA9IFtdO1xuICAgIC8vIE5vdGlmeSBlbGVtZW50IGFkZGVkXG4gICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gIH1cbiAgLyoqXG4gICogQ2hlY2sgaWYgaXMgcHJvcGVyIGVsZW1lbnQgb3IgZ3JvdXBcbiAgKi9cbiAgX19jaGVja0lmRWxfXyAoZWxlbWVudCkge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBCYXNpY0VsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcignT25seSBlbGVtZW50cyBvciBncm91cHMgY2FuIGJlIGFkZGVkJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIENoZWNrIGlmIGlzIHByb3BlciBncm91cFxuICAqL1xuICBfX2NoZWNrR3JvdXBfXyAoZWxlbWVudCkge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBHcm91cCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdHcm91cCBleHBlY3RlZCcpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBBZGQgbmV3IGVsZW1lbnRzIG9yIGdyb3Vwc1xuICAqIHRvIGN1cnJlbnQgZ3JvdXBcbiAgKi9cbiAgYWRkIChlbGVtZW50KSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIElmIEFycmF5IGFkZCBhbGwgZWxlbWVudHNcbiAgICBpZiAoIWlzTmFOKGVsZW1lbnQubGVuZ3RoKSkge1xuICAgICAgZm9yIChpID0gZWxlbWVudC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdGhpcy5hZGQoZWxlbWVudFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fX2NoZWNrSWZFbF9fKGVsZW1lbnQpO1xuICAgIC8vIFJlbW92ZSBwcmV2aW91cyBncm91cDtcbiAgICBpZiAoZWxlbWVudC5ncm91cCgpKSB7XG4gICAgICBlbGVtZW50Lmdyb3VwKCkucmVtb3ZlKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyBhc3NzaWduIG5ldyBncm91cFxuICAgIGVsZW1lbnQuX19ncm91cF9fID0gdGhpcztcbiAgICB0aGlzLl9fbWVtYmVyc19fLnB1c2goZWxlbWVudCk7XG4gICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogQWRkIG5ldyBlbGVtZW50cyBvciBncm91cHNcbiAgKiB0byBjdXJyZW50IGdyb3VwIGZyb20gZGlmZmVyZW50IGdyb3VwXG4gICovXG4gIGFkZEFsbEZyb20gKGdyb3VwKSB7XG4gICAgbGV0IGFycixcbiAgICAgIGkgPSAwO1xuICAgIHRoaXMuX19jaGVja0dyb3VwX18oZ3JvdXApO1xuICAgIGFyciA9IGdyb3VwLl9fbWVtYmVyc19fO1xuICAgIGZvciAoaSA9IGFyci5sZW5ndGg7IGktLTspIHtcblxuICAgIH1cbiAgfVxuICAvKipcbiAgKiBSZW1vdmUgZWxlbWVudCBpcyBtZW1iZXIgb2YgY3VycmVudCBncm91cFxuICAqL1xuICByZW1vdmUgKGVsZW1lbnQpIHtcbiAgICBsZXQgbWVtYmVycyA9IHRoaXMuX19tZW1iZXJzX18sXG4gICAgICBpID0gMCxcbiAgICAgIGlpID0gbWVtYmVycy5sZW5ndGgsXG4gICAgICBqID0gMDtcbiAgICB0aGlzLl9fY2hlY2tJZkVsX18oZWxlbWVudCk7XG4gICAgaSA9IG1lbWJlcnMuaW5kZXhPZihlbGVtZW50KTtcbiAgICBpZiAoIX5pKSB7IC8vIEVsZW1lbnQgbm90IGZvdW5kXG4gICAgICB0aHJvdyBFcnJvcignRWxlbWVudCBub3QgaW4gY3VycmVudCBncm91cCcpO1xuICAgIH0gZWxzZSB7IC8vIFJlbW92ZSB0aGUgZWxlbWVudFxuICAgICAgbWVtYmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICBkZWxldGUgZWxlbWVudC5ncm91cDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogUmVtb3ZlIGFsbCBlbGVtZW50c1xuICAqL1xuICByZW1vdmVBbGwgKCkge1xuICAgIGxldCBtZW1iZXJzID0gdGhpcy5fX21lbWJlcnNfXyxcbiAgICAgIGkgPSBtZW1iZXJzLmxlbmd0aDtcbiAgICBmb3IgKDsgaS0tOykge1xuICAgICAgbWVtYmVyc1tpXS5wb3AoKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXMgb2YgYWxsIGVsZW1lbnRzXG4gICAgdGhpcy5fX21lbWJlcnNfXyA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAqIE92ZXJyaWRpbmcgbWV0aG9kXG4gICogRXJhc2UgY3VycmVudCBncm91cCBhbmQgYWxsIGl0cyBjaGlsZHJlblxuICAqL1xuICBlcmFzZSAoKSB7XG4gICAgbGV0IG1lbWJlcnMgPSB0aGlzLl9fbWVtYmVyc19fLFxuICAgICAgaSA9IG1lbWJlcnMubGVuZ3RoO1xuICAgIC8vIHJlbW92ZSBhbGwgY2hpbGRyZW5cbiAgICBmb3IgKDsgaS0tOykge1xuICAgICAgbWVtYmVyc1tpXS5lcmFzZSgpO1xuICAgIH1cbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgICAvLyBSZW1vdmUgc2VsZlxuICAgIHN1cGVyLmVyYXNlKCk7XG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gdG8gY29tbWFuZCBhbGwgZ3JvdXAgZWxlbWVudCB0byBkcmF3IGl0c2VsZjtcbiAgKi9cbiAgX19kcmF3X18gKGNvbnRleHQpIHtcbiAgICBsZXQgbWVtYmVycyA9IHRoaXMuX19tZW1iZXJzX18sXG4gICAgICBpID0gMCxcbiAgICAgIC8vIElmIGdyb3VwIGlzIG5vdCBkcmF3biBjb21wbGV0ZWx5OyBtZW1iZXJzIGNoZWNrXG4gICAgICAvLyBJZiBub3QgY2FzZSA7IHdoZW4gZ3JvdXAgaXMgaW5pdGlhbGl6ZWQgaXRzIEJhc2ljRWxcbiAgICAgIC8vIGNvbnN0cnVjdG9yIGlzIGNhbGxlZCB3aGljaCBhZGRzIGl0IHRvcm9vdCBncm91cCBhbmQgY2FsbHNcbiAgICAgIC8vIGZvciBfX25vdGlmeV9fIHdoaWNoIHRoZW4gY29tbWFuZHMgYWxsIGdyb3VwIHRvIGRyYXdcbiAgICAgIC8vIGJ1dCB0aGVuIHRoaXMgZ3JvdXAgd291bGQgbm90IGhhdmUgaXRzIG1lbWJlciBhcyBpdHMgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGlzIG5vdCBjb21wbGV0ZSB0aHVzIHdpbGwgY2F1c2UgZXJyb3JcbiAgICAgIGlpID0gbWVtYmVycyAmJiBtZW1iZXJzLmxlbmd0aCB8fCAwO1xuICAgIC8vIEl0ZXJhdGluZyBvdmVyIGVhY2ggbWVtYmVyO1xuICAgIC8vIGNvbW1hbmRpbmcgdG8gZHJhd1xuICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgbWVtYmVyc1tpXS5fX2RyYXdfXyhjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogUHVzaCBlbGVtZW50IHRvIGxhc3QgaW4gdGhlIGdyb3VwXG4gICovXG4gIF9fc2VuZFRvQmFja19fIChlbCkge1xuICAgIGxldCBtZW1iZXJzID0gdGhpcy5fX21lbWJlcnNfXyxcbiAgICAgIGkgPSAwLFxuICAgICAgcG9zID0gLTE7XG4gICAgdGhpcy5fX2NoZWNrSWZFbF9fKGVsKTtcbiAgICBwb3MgPSBtZW1iZXJzLmluZGV4T2YoZWwpO1xuICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICBmb3IgKGkgPSBwb3MgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtZW1iZXJzW2kgKyAxXSA9IG1lbWJlcnNbaV07XG4gICAgICB9XG4gICAgICBtZW1iZXJzWzBdID0gZWw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIFB1c2ggZWxlbWVudCB0byBsYXN0IGluIHRoZSBncm91cFxuICAqL1xuICBfX3NlbmRUb0Zyb250X18gKGVsKSB7XG4gICAgbGV0IG1lbWJlcnMgPSB0aGlzLl9fbWVtYmVyc19fLFxuICAgICAgaSA9IDAsXG4gICAgICBpaSA9IG1lbWJlcnMubGVuZ3RoLFxuICAgICAgcG9zID0gLTE7XG4gICAgdGhpcy5fX2NoZWNrSWZFbF9fKGVsKTtcbiAgICBwb3MgPSBtZW1iZXJzLmluZGV4T2YoZWwpO1xuICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICBmb3IgKGkgPSBwb3MgKyAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBtZW1iZXJzW2kgLSAxXSA9IG1lbWJlcnNbaV07XG4gICAgICB9XG4gICAgICBtZW1iZXJzW2lpIC0gMV0gPSBlbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4qIExpbmUgZWxlbWVudFxuKi9cbmNsYXNzIFJlY3QgZXh0ZW5kcyBCYXNpY0VsZW1lbnQge1xuICBjb25zdHJ1Y3RvciAoY2FudmFzLCBlbENvbmZpZywgZ3JvdXApIHtcbiAgICBzdXBlcihjYW52YXMsIGdyb3VwKTtcbiAgICB0aGlzLmNvbmZpZy50eXBlID0gJ3JlY3QnO1xuICAgIHRoaXMuZWxDb25maWcgPSBlbENvbmZpZztcbiAgICAvLyBOb3RpZnkgZWxlbWVudCBhZGRlZFxuICAgIHRoaXMuX19ub3RpZnlDaGFuZ2VfXygpO1xuICB9XG4gIC8qKlxuICAqIEZ1bmN0aW9uIHRvIGRlc2NyaWJlIGhvdyBlbGVtZW50IHdpbGwgYmUgZHJhd25cbiAgKi9cbiAgX19hdHRyX18gKGNvbmZpZykge1xuXG4gIH1cbiAgLyoqXG4gICogRnVuY3Rpb24gdG8gZGVzY3JpYmUgaG93IGVsZW1lbnQgd2lsbCBiZSBkcmF3blxuICAqL1xuICBfX2RyYXdfXyAoY29udGV4dCkge1xuICAgIGxldCBpLFxuICAgICAgcmVjdCA9IHRoaXMsXG4gICAgICBjb25maWcgPSByZWN0LmVsQ29uZmlnO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5yZWN0KGNvbmZpZy54LCBjb25maWcueSwgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0KTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbmZpZy5maWxsIHx8IGxpYkRlZmF1bHRzLmZpbGw7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbmZpZy5zdHJva2UgfHwgbGliRGVmYXVsdHMuc3Ryb2tlO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gY29uZmlnLnN0cm9rZVdpZHRoIHx8IGxpYkRlZmF1bHRzLnN0cm9rZVdpZHRoO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbn0gLy8gZW5kIExpbmVcblxuLy8gQ2xhc3MgdG8gbWFuYWdlIHJlbmRlcmluZyBvZiBlbGVtZW50c1xuY2xhc3MgUGFpbnRlciB7XG4gIGNvbnN0cnVjdG9yIChpZCwgaGVpZ2h0LCB3aWR0aCwgcm9vdEdyb3VwKSB7XG4gICAgbGV0IHBhaW50ZXIgPSB0aGlzLFxuICAgICAgY2FudmFzO1xuICAgIHBhaW50ZXIuY2FudmFzID0ge1xuICAgICAgcm9vdEVsOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgICBjYW52YXNFbDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG4gICAgICBoZWlnaHQ6IGhlaWdodCB8fCBsaWJEZWZhdWx0cy5jYW52YXNIZWlnaHQsXG4gICAgICB3aWR0aDogd2lkdGggfHwgbGliRGVmYXVsdHMuY2FudmFzV2lkdGhcbiAgICB9O1xuICAgIGNhbnZhcyA9IHBhaW50ZXIuY2FudmFzO1xuICAgIGNhbnZhcy5yb290RWwuYXBwZW5kQ2hpbGQoY2FudmFzLmNhbnZhc0VsKTtcbiAgICAvLyBTZXR0aW5nIGhlaWdodCBhbmQgd2lkdGggb2YgY2FudmFzXG4gICAgY2FudmFzLmNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjYW52YXMud2lkdGgpO1xuICAgIGNhbnZhcy5jYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNhbnZhcy5oZWlnaHQpO1xuICAgIC8vIFNldHRpbmcgZmFsbGJhY2tcbiAgICBjYW52YXMuY2FudmFzRWwuaW5uZXJIVE1MID0gJ1lvdXIgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCBjYW52YXMhJztcbiAgICAvLyBHZXR0aW5nIGNvbnRleHQgYW5kIHJvb3QgZ3JvdXBcbiAgICBjYW52YXMuY29udGV4dCA9IGNhbnZhcy5jYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy5yb290R3JvdXAgPSByb290R3JvdXA7XG4gICAgdGhpcy5jbGVhckNhbnZhcygpO1xuICB9XG4gIC8qKlxuICAqIENsZWFyaW5nIGNhbnZhcyB3aXRoIHN0YXRlIHNhdmVkXG4gICovXG4gIGNsZWFyQ2FudmFzIChzYXZlU3RhdGUpIHtcbiAgICBsZXQgcGFpbnRlciA9IHRoaXMsXG4gICAgICBjYW52YXMgPSBwYWludGVyLmNhbnZhcyxcbiAgICAgIGNvbnRleHQgPSBjYW52YXMuY29udGV4dDtcbiAgICAvLyBTdG9yZSB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICBpZiAoc2F2ZVN0YXRlKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICB9XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY29udGV4dC5yZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAvLyBSZXN0b3JlIHRoZSB0cmFuc2Zvcm1cbiAgICBpZiAoc2F2ZVN0YXRlKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgLy8gUGFpbnQgYWxsIHZpc2libGUgaXRlbXM7XG4gIHBhaW50QWxsICgpIHtcbiAgICB0aGlzLmNsZWFyQ2FudmFzKCk7XG4gICAgdGhpcy5jYW52YXMucm9vdEdyb3VwLmRyYXcodGhpcy5jYW52YXMuY29udGV4dCk7XG4gIH1cbn1cblxuJ3VzZSBzdHJpY3QnO1xudmFyIHBhcGVyID0gbmV3IENhbnZhc0xpdGUoJ2NhbnZhcycsIDkwMCwgOTAwKSxcbiAgcm9vdEdyb3VwID0gcGFwZXIucm9vdEdyb3VwLFxuICByMCA9IHBhcGVyLnJlY3QoMCwgMCwgMTAwLCAxMDAsICcjRTk3NTkyJywgJyNGRkFDOEInKSxcbiAgcjEgPSBwYXBlci5yZWN0KDY2LCA1NSwgMTAwLCAxMDAsICcjQjdBQzU0JywgJyM5NUI4MzAnKSxcbiAgcjIgPSBwYXBlci5yZWN0KDExNCwgMTI2LCAxMDAsIDEwMCwgJyNCRUM0QTEnLCAnIzBBREFBNScpLFxuICByMyA9IHBhcGVyLnJlY3QoMTk0LCAxNDgsIDEwMCwgMTAwLCAnIzAzNUM2OScsICcjOEE4QkYzJyksXG4gIHI0ID0gcGFwZXIucmVjdCgyNTUsIDE4MiwgMTAwLCAxMDAsICcjNEYxMTY4JywgJyNBODdFMjEnKSxcbiAgcjUgPSBwYXBlci5yZWN0KDI3NSwgMjU5LCAxMDAsIDEwMCwgJyM5MUU0MDAnLCAnIzNBQjc4RScpLFxuICByNiA9IHBhcGVyLnJlY3QoMzUwLCAzMTAsIDEwMCwgMTAwLCAnIzczRjFFNicsICcjQ0FBQzZDJyksXG4gIHI3ID0gcGFwZXIucmVjdCgzNTEsIDM3NSwgMTAwLCAxMDAsICcjRDMwMDlDJywgJyNGRjQ0OTQnKSxcbiAgcjggPSBwYXBlci5yZWN0KDM5NSwgMzc2LCAxMDAsIDEwMCwgJyM5N0JENzcnLCAnIzlFQ0Q4OScpLFxuICByOSA9IHBhcGVyLnJlY3QoNDg4LCA0NjIsIDEwMCwgMTAwLCAnIzJEMTM4NScsICcjREJCMTZBJyksXG4gIHIxMCA9IHBhcGVyLnJlY3QoNDk3LCA1MjMsIDEwMCwgMTAwLCAnIzg4ODQ0NycsICcjMDcxNkNCJyksXG4gIHIxMSA9IHBhcGVyLnJlY3QoNTYxLCA2MDAsIDEwMCwgMTAwLCAnI0UyQjFGQScsICcjQ0Q0MDMxJyksXG4gIHIxMiA9IHBhcGVyLnJlY3QoNTkzLCA2NDgsIDEwMCwgMTAwLCAnIzcxMkMzNScsICcjQzA5N0VCJyksXG4gIHIxMyA9IHBhcGVyLnJlY3QoNjEyLCA2OTUsIDEwMCwgMTAwLCAnIzhENUQ3RScsICcjM0IyNTBGJyksXG4gIHIxNCA9IHBhcGVyLnJlY3QoNjg5LCA2OTYsIDEwMCwgMTAwLCAnIzJBOEM1QScsICcjRENBREJCJyksXG4gIGcgPSBwYXBlci5ncm91cCgpLFxuICBlcnJvciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxcbiAgeCA9IDAsXG4gIHkgPSAwLFxuICBoID0gMCxcbiAgdyA9IDAsXG4gIHQgPSAwO1xuXG5pZiAocm9vdEdyb3VwLl9fbWVtYmVyc19fLmxlbmd0aCAhPT0gMTYpIHtcbiAgZXJyb3IoJ01lbWJlcnMgbGVuZ3RoIG5vdCBjb3JyZWN0Jyk7XG59XG5cbmcuYWRkKFtyMSwgcjMsIHI1XSk7XG5nLmhpZGUoKTtcblxuaWYgKHJvb3RHcm91cC5fX21lbWJlcnNfXy5sZW5ndGggIT09IDEzKSB7XG4gIGVycm9yKCdNZW1iZXJzIGxlbmd0aCBub3QgY29ycmVjdCBhZnRlciBhcHBlbmRpbmcgaXRlbXMgaW4gZ3JvdXAnKTtcbn1cblxuaWYgKGcuY29uZmlnLnZpc2libGUpIHtcbiAgZXJyb3IoJ0VsZW1lbnQgbm90IGhpZGRlbicpO1xufVxuXG5nLnNob3coKTtcblxuaWYgKCFnLmNvbmZpZy52aXNpYmxlKSB7XG4gIGVycm9yKCdFbGVtZW50IG5vdCBzaG93bicpO1xufVxuXG5nLmVyYXNlKCk7XG5cbmlmIChnLl9fcHJvdG9fXykge1xuICBlcnJvcignR3JvdXAgbm90IGVyYXNlZCcpO1xufVxuaWYgKHIxLl9fcHJvdG9fXykge1xuICBlcnJvcignR3JvdXAgbWVtYmVyIG5vdCBlcmFzZWQnKTtcbn1cbmlmIChyMy5fX3Byb3RvX18pIHtcbiAgZXJyb3IoJ0dyb3VwIG1lbWJlciBub3QgZXJhc2VkJyk7XG59XG5pZiAocjUuX19wcm90b19fKSB7XG4gIGVycm9yKCdHcm91cCBtZW1iZXIgbm90IGVyYXNlZCcpO1xufVxuXG5yMSA9IHBhcGVyLnJlY3QoNjYsIDU1LCAxMDAsIDEwMCwgJyNCN0FDNTQnLCAnIzk1QjgzMCcpO1xucjMgPSBwYXBlci5yZWN0KDE5NCwgMTQ4LCAxMDAsIDEwMCwgJyMwMzVDNjknLCAnIzhBOEJGMycpO1xucjUgPSBwYXBlci5yZWN0KDI3NSwgMjU5LCAxMDAsIDEwMCwgJyM5MUU0MDAnLCAnIzNBQjc4RScpO1xuZyA9IHBhcGVyLmdyb3VwKCk7XG5nLmFkZChbcjEsIHIzLCByNV0pO1xuXG5pZiAocm9vdEdyb3VwLl9fbWVtYmVyc19fLmxlbmd0aCAhPT0gMTMpIHtcbiAgZXJyb3IoJ01lbWJlcnMgbGVuZ3RoIG5vdCBjb3JyZWN0Jyk7XG59XG5cbmlmIChnLl9fbWVtYmVyc19fLmxlbmd0aCAhPT0gMykge1xuICBlcnJvcignTWVtYmVycyBsZW5ndGggbm90IGNvcnJlY3QnKTtcbn1cbn0od2luZG93LCBkb2N1bWVudCkpO1xuIl0sImZpbGUiOiJjYW52YXNsaXRlLWVzNi5taW4uanMifQ==
