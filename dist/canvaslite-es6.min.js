(function(window, document, undefined) {
"use strict";

/**
* Constructor function to initialize CanvasLite
*/
class CanvasLite {
  constructor (id) {
    this.rootGroup = new Group(this, null, true);
    this.brush = new Painter(id, this.rootGroup);
  }
  element () {
    return new BasicElement(this);
  }
  group () {
    return new Group(this);
  }
}
// Exposing CanvasLite to global space
window.CanvasLite = CanvasLite;

/**
* Basic Element class
* Groups and other Elements inherits this
* contains basic methods and properties required by all groups or elements.
*/
class BasicElement {
  /**
  * BasiElement constructor
  * assign the group, store canvas
  * set type initially to 'basicEl'
  */
  constructor (canvas, group, isRoot) {
    if (!canvas) {
      throw Error('canvas not provided');
    }
    this.canvas = canvas;
    this.config = {
      type: 'basicEl',
      visible: true
    };
    this.isRoot = !!isRoot;
    // Initially assign root group if
    // group not provided
    if (group) {
      if (!(group instanceof Group)) {
        throw Error('Not a proper Group');
      }
      group.add(this);
    } else {
      if (!isRoot) {
        canvas.rootGroup.add(this);
      }
    }
    // Notify element added
    this.__notifyChange__();
  }
  /**
  * Assign new group or
  * get the current assigned group
  */
  group (group) {
    // If group is provided assign, otherwise
    // return current group
    var res;
    if (group) {
      this.group.remove(this);
      this.group = group;
      res = this;
    } else {
      res = this.group;
    }
    // Notify group changed
    this.__notifyChange__();
    return res;
  }
  /**
  * Erase current element
  */
  erase () {
    var key;
    this.group.remove(this);
    // delete every property of element
    for (key in this) {
      if (this.hasOwnProperty(key)) {
        delete this[key];
      }
    }
    // Notify element erased
    this.__notifyChange__();
  }
  /**
  * Hide current element
  */
  hide () {
    if (this.config.visible) {
      this.config.visible = false;
      this.__notifyChange__();
    }
    return this;
  }
  /**
  * Show current element
  */
  show () {
    if (!this.config.visible) {
      this.config.visible = true;
      this.__notifyChange__();
    }
    return this;
  }
  /**
  * Toggle current element's visibility
  */
  toggle () {
    this.config.visible = !this.config.visible;
    this.__notifyChange__();
    return this;
  }
  /**
  * Behave when property of element is changed
  */
  __notifyChange__ () {
    if (this.config && this.config.visible) {
      // Notify change only if visible
      // and if element exists
    }
  }
}

/**
* Manage groups that elements belong to
* extends BasicElement
*/
class Group extends BasicElement {
  constructor (canvas, group, isRoot) {
    super(canvas, group, isRoot);
    // Set type to group
    this.config.type = 'group';
    this.__members__ = [];
  }
  /**
  * Check if is proper element or group
  */
  __checkEl__ (element) {
    if (!(element instanceof BasicElement)) {
      throw Error('Only elements or groups can be added');
    }
  }
  /**
  * Check if is proper group
  */
  __checkGroup__ (element) {
    if (!(element instanceof Group)) {
      throw Error('Group expected');
    }
  }
  /**
  * Add new elements or groups
  * to current group
  */
  add (element) {
    let i = 0;
    // If Array add all elements
    if (!isNaN(element.length)) {
      for (i = element.length; i--;) {
        this.add(element[i]);
      }
      return this;
    }
    this.__checkEl__(element);
    // Remove previous group;
    if (element.group.remove) {
      element.group.remove(element);
    }
    // asssign new group
    element.group = this;
    this.__members__.push(element);
    return this;
  }
  /**
  * Add new elements or groups
  * to current group from different group
  */
  addAllFrom (group) {
    let arr,
      i = 0;
    this.__checkGroup__(group);
    arr = group.__members__;
    for (i = arr.length; i--;) {

    }
  }
  /**
  * Remove element is member of current group
  */
  remove (element) {
    let members = this.__members__,
      i = 0,
      ii = members.length,
      j = 0;
    this.__checkEl__(element);
    for (; i < ii; ++i) {
      if (members[i] === element) {
        break;
      }
    }
    if (i === ii) { // Element not found
      throw Error('Element not in current group');
    } else { // Remove the element
      for (j = i + 1; j < ii; ++j) {
        members[j - 1] = members[j];
      }
      members.pop();
      delete element.group;
    }
    return this;
  }
  /**
  * Remove all elements
  */
  removeAll () {
    let members = this.__members__,
      i = members.length;
    for (; i--;) {
      delete members[i].group;
    }
    // Remove references of all elements
    this.__members__ = [];
    return this;
  }
  /**
  * Overriding method
  * Erase current group and all its children
  */
  erase () {
    let members = this.__members__,
      i = members.length;
    // remove all children
    for (; i--;) {
      members[i].erase();
    }
    // Remove self
    super.erase();
  }
}

// Class to manage rendering of elements
class Painter {
  constructor (id, rootGroup) {
    this.rootEl = document.getElementById(id);
    this.canvasEl = document.createElement('canvas');
    this.rootEl.appendChild(this.canvasEl);
    this.context = this.canvasEl.getContext('2d');
    this.rootGroup = rootGroup;
  }
}
}(window, document));

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJjYW52YXNsaXRlLWVzNi5taW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbml0aWFsaXplIENhbnZhc0xpdGVcbiovXG5jbGFzcyBDYW52YXNMaXRlIHtcbiAgY29uc3RydWN0b3IgKGlkKSB7XG4gICAgdGhpcy5yb290R3JvdXAgPSBuZXcgR3JvdXAodGhpcywgbnVsbCwgdHJ1ZSk7XG4gICAgdGhpcy5icnVzaCA9IG5ldyBQYWludGVyKGlkLCB0aGlzLnJvb3RHcm91cCk7XG4gIH1cbiAgZWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIG5ldyBCYXNpY0VsZW1lbnQodGhpcyk7XG4gIH1cbiAgZ3JvdXAgKCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAodGhpcyk7XG4gIH1cbn1cbi8vIEV4cG9zaW5nIENhbnZhc0xpdGUgdG8gZ2xvYmFsIHNwYWNlXG53aW5kb3cuQ2FudmFzTGl0ZSA9IENhbnZhc0xpdGU7XG5cbi8qKlxuKiBCYXNpYyBFbGVtZW50IGNsYXNzXG4qIEdyb3VwcyBhbmQgb3RoZXIgRWxlbWVudHMgaW5oZXJpdHMgdGhpc1xuKiBjb250YWlucyBiYXNpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHJlcXVpcmVkIGJ5IGFsbCBncm91cHMgb3IgZWxlbWVudHMuXG4qL1xuY2xhc3MgQmFzaWNFbGVtZW50IHtcbiAgLyoqXG4gICogQmFzaUVsZW1lbnQgY29uc3RydWN0b3JcbiAgKiBhc3NpZ24gdGhlIGdyb3VwLCBzdG9yZSBjYW52YXNcbiAgKiBzZXQgdHlwZSBpbml0aWFsbHkgdG8gJ2Jhc2ljRWwnXG4gICovXG4gIGNvbnN0cnVjdG9yIChjYW52YXMsIGdyb3VwLCBpc1Jvb3QpIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NhbnZhcyBub3QgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICB0eXBlOiAnYmFzaWNFbCcsXG4gICAgICB2aXNpYmxlOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLmlzUm9vdCA9ICEhaXNSb290O1xuICAgIC8vIEluaXRpYWxseSBhc3NpZ24gcm9vdCBncm91cCBpZlxuICAgIC8vIGdyb3VwIG5vdCBwcm92aWRlZFxuICAgIGlmIChncm91cCkge1xuICAgICAgaWYgKCEoZ3JvdXAgaW5zdGFuY2VvZiBHcm91cCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vdCBhIHByb3BlciBHcm91cCcpO1xuICAgICAgfVxuICAgICAgZ3JvdXAuYWRkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgICBjYW52YXMucm9vdEdyb3VwLmFkZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm90aWZ5IGVsZW1lbnQgYWRkZWRcbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgfVxuICAvKipcbiAgKiBBc3NpZ24gbmV3IGdyb3VwIG9yXG4gICogZ2V0IHRoZSBjdXJyZW50IGFzc2lnbmVkIGdyb3VwXG4gICovXG4gIGdyb3VwIChncm91cCkge1xuICAgIC8vIElmIGdyb3VwIGlzIHByb3ZpZGVkIGFzc2lnbiwgb3RoZXJ3aXNlXG4gICAgLy8gcmV0dXJuIGN1cnJlbnQgZ3JvdXBcbiAgICB2YXIgcmVzO1xuICAgIGlmIChncm91cCkge1xuICAgICAgdGhpcy5ncm91cC5yZW1vdmUodGhpcyk7XG4gICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XG4gICAgICByZXMgPSB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLmdyb3VwO1xuICAgIH1cbiAgICAvLyBOb3RpZnkgZ3JvdXAgY2hhbmdlZFxuICAgIHRoaXMuX19ub3RpZnlDaGFuZ2VfXygpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICogRXJhc2UgY3VycmVudCBlbGVtZW50XG4gICovXG4gIGVyYXNlICgpIHtcbiAgICB2YXIga2V5O1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgIC8vIGRlbGV0ZSBldmVyeSBwcm9wZXJ0eSBvZiBlbGVtZW50XG4gICAgZm9yIChrZXkgaW4gdGhpcykge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkZWxldGUgdGhpc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3RpZnkgZWxlbWVudCBlcmFzZWRcbiAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgfVxuICAvKipcbiAgKiBIaWRlIGN1cnJlbnQgZWxlbWVudFxuICAqL1xuICBoaWRlICgpIHtcbiAgICBpZiAodGhpcy5jb25maWcudmlzaWJsZSkge1xuICAgICAgdGhpcy5jb25maWcudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAqIFNob3cgY3VycmVudCBlbGVtZW50XG4gICovXG4gIHNob3cgKCkge1xuICAgIGlmICghdGhpcy5jb25maWcudmlzaWJsZSkge1xuICAgICAgdGhpcy5jb25maWcudmlzaWJsZSA9IHRydWU7XG4gICAgICB0aGlzLl9fbm90aWZ5Q2hhbmdlX18oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogVG9nZ2xlIGN1cnJlbnQgZWxlbWVudCdzIHZpc2liaWxpdHlcbiAgKi9cbiAgdG9nZ2xlICgpIHtcbiAgICB0aGlzLmNvbmZpZy52aXNpYmxlID0gIXRoaXMuY29uZmlnLnZpc2libGU7XG4gICAgdGhpcy5fX25vdGlmeUNoYW5nZV9fKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogQmVoYXZlIHdoZW4gcHJvcGVydHkgb2YgZWxlbWVudCBpcyBjaGFuZ2VkXG4gICovXG4gIF9fbm90aWZ5Q2hhbmdlX18gKCkge1xuICAgIGlmICh0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy52aXNpYmxlKSB7XG4gICAgICAvLyBOb3RpZnkgY2hhbmdlIG9ubHkgaWYgdmlzaWJsZVxuICAgICAgLy8gYW5kIGlmIGVsZW1lbnQgZXhpc3RzXG4gICAgfVxuICB9XG59XG5cbi8qKlxuKiBNYW5hZ2UgZ3JvdXBzIHRoYXQgZWxlbWVudHMgYmVsb25nIHRvXG4qIGV4dGVuZHMgQmFzaWNFbGVtZW50XG4qL1xuY2xhc3MgR3JvdXAgZXh0ZW5kcyBCYXNpY0VsZW1lbnQge1xuICBjb25zdHJ1Y3RvciAoY2FudmFzLCBncm91cCwgaXNSb290KSB7XG4gICAgc3VwZXIoY2FudmFzLCBncm91cCwgaXNSb290KTtcbiAgICAvLyBTZXQgdHlwZSB0byBncm91cFxuICAgIHRoaXMuY29uZmlnLnR5cGUgPSAnZ3JvdXAnO1xuICAgIHRoaXMuX19tZW1iZXJzX18gPSBbXTtcbiAgfVxuICAvKipcbiAgKiBDaGVjayBpZiBpcyBwcm9wZXIgZWxlbWVudCBvciBncm91cFxuICAqL1xuICBfX2NoZWNrRWxfXyAoZWxlbWVudCkge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBCYXNpY0VsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcignT25seSBlbGVtZW50cyBvciBncm91cHMgY2FuIGJlIGFkZGVkJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIENoZWNrIGlmIGlzIHByb3BlciBncm91cFxuICAqL1xuICBfX2NoZWNrR3JvdXBfXyAoZWxlbWVudCkge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBHcm91cCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdHcm91cCBleHBlY3RlZCcpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBBZGQgbmV3IGVsZW1lbnRzIG9yIGdyb3Vwc1xuICAqIHRvIGN1cnJlbnQgZ3JvdXBcbiAgKi9cbiAgYWRkIChlbGVtZW50KSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIElmIEFycmF5IGFkZCBhbGwgZWxlbWVudHNcbiAgICBpZiAoIWlzTmFOKGVsZW1lbnQubGVuZ3RoKSkge1xuICAgICAgZm9yIChpID0gZWxlbWVudC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdGhpcy5hZGQoZWxlbWVudFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fX2NoZWNrRWxfXyhlbGVtZW50KTtcbiAgICAvLyBSZW1vdmUgcHJldmlvdXMgZ3JvdXA7XG4gICAgaWYgKGVsZW1lbnQuZ3JvdXAucmVtb3ZlKSB7XG4gICAgICBlbGVtZW50Lmdyb3VwLnJlbW92ZShlbGVtZW50KTtcbiAgICB9XG4gICAgLy8gYXNzc2lnbiBuZXcgZ3JvdXBcbiAgICBlbGVtZW50Lmdyb3VwID0gdGhpcztcbiAgICB0aGlzLl9fbWVtYmVyc19fLnB1c2goZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogQWRkIG5ldyBlbGVtZW50cyBvciBncm91cHNcbiAgKiB0byBjdXJyZW50IGdyb3VwIGZyb20gZGlmZmVyZW50IGdyb3VwXG4gICovXG4gIGFkZEFsbEZyb20gKGdyb3VwKSB7XG4gICAgbGV0IGFycixcbiAgICAgIGkgPSAwO1xuICAgIHRoaXMuX19jaGVja0dyb3VwX18oZ3JvdXApO1xuICAgIGFyciA9IGdyb3VwLl9fbWVtYmVyc19fO1xuICAgIGZvciAoaSA9IGFyci5sZW5ndGg7IGktLTspIHtcblxuICAgIH1cbiAgfVxuICAvKipcbiAgKiBSZW1vdmUgZWxlbWVudCBpcyBtZW1iZXIgb2YgY3VycmVudCBncm91cFxuICAqL1xuICByZW1vdmUgKGVsZW1lbnQpIHtcbiAgICBsZXQgbWVtYmVycyA9IHRoaXMuX19tZW1iZXJzX18sXG4gICAgICBpID0gMCxcbiAgICAgIGlpID0gbWVtYmVycy5sZW5ndGgsXG4gICAgICBqID0gMDtcbiAgICB0aGlzLl9fY2hlY2tFbF9fKGVsZW1lbnQpO1xuICAgIGZvciAoOyBpIDwgaWk7ICsraSkge1xuICAgICAgaWYgKG1lbWJlcnNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBpaSkgeyAvLyBFbGVtZW50IG5vdCBmb3VuZFxuICAgICAgdGhyb3cgRXJyb3IoJ0VsZW1lbnQgbm90IGluIGN1cnJlbnQgZ3JvdXAnKTtcbiAgICB9IGVsc2UgeyAvLyBSZW1vdmUgdGhlIGVsZW1lbnRcbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgaWk7ICsraikge1xuICAgICAgICBtZW1iZXJzW2ogLSAxXSA9IG1lbWJlcnNbal07XG4gICAgICB9XG4gICAgICBtZW1iZXJzLnBvcCgpO1xuICAgICAgZGVsZXRlIGVsZW1lbnQuZ3JvdXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAqIFJlbW92ZSBhbGwgZWxlbWVudHNcbiAgKi9cbiAgcmVtb3ZlQWxsICgpIHtcbiAgICBsZXQgbWVtYmVycyA9IHRoaXMuX19tZW1iZXJzX18sXG4gICAgICBpID0gbWVtYmVycy5sZW5ndGg7XG4gICAgZm9yICg7IGktLTspIHtcbiAgICAgIGRlbGV0ZSBtZW1iZXJzW2ldLmdyb3VwO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgcmVmZXJlbmNlcyBvZiBhbGwgZWxlbWVudHNcbiAgICB0aGlzLl9fbWVtYmVyc19fID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICogT3ZlcnJpZGluZyBtZXRob2RcbiAgKiBFcmFzZSBjdXJyZW50IGdyb3VwIGFuZCBhbGwgaXRzIGNoaWxkcmVuXG4gICovXG4gIGVyYXNlICgpIHtcbiAgICBsZXQgbWVtYmVycyA9IHRoaXMuX19tZW1iZXJzX18sXG4gICAgICBpID0gbWVtYmVycy5sZW5ndGg7XG4gICAgLy8gcmVtb3ZlIGFsbCBjaGlsZHJlblxuICAgIGZvciAoOyBpLS07KSB7XG4gICAgICBtZW1iZXJzW2ldLmVyYXNlKCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWxmXG4gICAgc3VwZXIuZXJhc2UoKTtcbiAgfVxufVxuXG4vLyBDbGFzcyB0byBtYW5hZ2UgcmVuZGVyaW5nIG9mIGVsZW1lbnRzXG5jbGFzcyBQYWludGVyIHtcbiAgY29uc3RydWN0b3IgKGlkLCByb290R3JvdXApIHtcbiAgICB0aGlzLnJvb3RFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICB0aGlzLmNhbnZhc0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5yb290RWwuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXNFbCk7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMucm9vdEdyb3VwID0gcm9vdEdyb3VwO1xuICB9XG59XG59KHdpbmRvdywgZG9jdW1lbnQpKTtcbiJdLCJmaWxlIjoiY2FudmFzbGl0ZS1lczYubWluLmpzIn0=
